<!doctype html>
<html lang="en">
  	<head>
		<!-- Required meta tags -->
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

		<!-- Bootstrap CSS -->
		<link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.4.1/css/bootstrap.min.css" integrity="sha384-Vkoo8x4CGsO3+Hhxv8T/Q5PaXtkKtu6ug5TOeNV6gBiFeWPGFN9MuhOf23Q9Ifjh" crossorigin="anonymous">
		<style>
			code{
				background-color: rgba(0,0,0,.075);
				font-weight: bold;
			}
			.subtitle{
				font-size: 1.3rem;
				font-weight: bold;
				margin: 0;
				padding: 5px;
				margin-top: 5px;
				background-color: rgba(0,0,0,.075);
				text-align: center;
			}
			h3{
				font-size: 2rem;
				font-weight: bold;
				margin: 0;
				padding: 5px;
				margin-top: 10px;
			}
			.paragraph{
				margin: 0.5rem 0 0.5rem;
			}
			.tab{
				margin: 0 1rem;
			}
			html{
				scroll-behavior: smooth;
			}
			</style>

		<title>26 React Performance</title>
  	</head>
  	<body>
      
    <div class="container">
		<h1 class="display-3 text-center">26 React Performance<hr></h1>
		<header>
			<p class="paragraph">
				Overall description.
			</p>
		</header>

		<h2 id="00" class="subtitle">Index</h2>
		<table class="table table-striped">
			<thead>
				<tr>
					<th scope="col">#</th>
					<th scope="col">Topic</th>
					<th scope="col">Description</th>
				</tr>
			</thead>
			<tbody>
				<tr>
					<th scope="row">1</th>
					<td>
						<a href="#01">topicName</a>
					</td>
					<td>
						<code>Code or description</code>
					</td>
				</tr>
			</tbody>
		</table>

		<ul class="list-group">
			<li class="list-group-item">
				<a id="01" href="#00">Index</a>
				<h2 class="subtitle">Code Splitting Intro</h2>
				<p class="paragraph">
					Performance varies between development and production builds. Don't optimize code ahead of time, only optimize once there is a problem. You can only optimize code if you measured that the code is running slow. Over optimizing might actually make things slower, the only way to find out is through measuring. We will talk about <strong>chunking</strong>. 
				</p>
				<p class="paragraph">
					<strong>DevTools App Files in Network Tab</strong>
					<br>
					We go to the Heroku version of our page and then we open the network tab and do a hard refresh <em>ctrl+shift+r</em>. The list that we get are the files that represent our app. We see that we get a .css file which we don't get in dev because we don't compile until production. We have a *chunk.js file whcih holds all of the DOM Libs that we are using. We have a main.*.chunk.js which holds all of the React code that we wrote ourselves. We see the pngs that we used. If we refresh normally, we see that the files are not re-loaded but remain in the cache making loading faster and it is done automatically by the browser. We can see that the files are actually much smaller as well. 
				</p>
				<p class="paragraph">
					<strong>main chunk</strong>
					<br>
					The files are called bundles of code, with our main chunk we have downloaded all of the JS code for our app, shop page, colleciton page, etc etc... Why do we need to download that if we have'nt visited those pages. We can split this so that they are downloaded when they are actually needed. This is called code splitting. We only need to do small modifications to split the code because it comes built into CRA. 
				</p>
				<a id="02" href="#00">Index</a>
				<h2 class="subtitle">React Lazy + Suspense</h2>
				<p class="paragraph">
					As of now we have all of our code merged into one single file due to Webpack. The default is using a static import, where we bundle all of our imports together. We want to leverage <em>dynamic import</em> syntax, which loads the imports when they are needed. This is possible due to Babel which comes with CRA. To use this we just import lazy from react in our App.tsx. This integrates very well with React Router, where we use the lazy Fn to lazy load our components. When we do this, webpack creates chunks of code to be loaded depending on the Component that we visit when we get re-routed. <em>We can only leverage this wherever there are Routes.</em>
				</p>
				<p class="paragraph">
					<strong>React Lazy + Suspense</strong>
					<br>
					To use this power we do <code>const HomePage = lazy(()=> import('./pages/homepage/homepage.component'))</code> to replace our old import. Now our chunk contains everything in our app except HomePage which is now handled by lazy() meaning that when the Route for HomePage gets triggered, a new chunk will be sent to the browser, meaning that we cang get a quicker load because our starting bundle is smaller. 
				</p>
				<p class="paragraph">
					<strong>Suspense</strong>
					<br>
					This is a new Component from React that is wrapped around any part of our App that will be rendering async components. It is <em>meant to be used with lazy</em>. We wrap it around our Route that holds HomePage <code>Suspense fallback={div...Loading/div}</code> which will render what we place in fallback while a component is loaded. If we look in our console Network tab we can see that we have our main chunk and alos a 0.chunk.js which is the first chunk of our App. Now we have 2 chunks instead of one. We do this to all of our Route Components and then wrap them all around a single suspense Component. <strong>Note:</strong> Not doing this will cause all pages after the first one not render at all.
				</p>
				<p class="paragraph">
					<strong>WithSpinner to Spinner</strong>
					<br>
					We create spinner/spinner.component.tsx and styles file. We copy the style from WithSpinner which we use as a HOC, and then we import React and our styles for the Spinner Component. We create a <code>const Spinner = () => ( ... )</code> That just renders SpinnerOverlay with SpinnerContainer inside. Then we export as default. We Refactor our WithSpinner Component. We remove the Code we just duplicated and remove the style import and just import Spinner and replace it in our code. I had the Component refactored in my code already. We can delete WithSpinner styles becasue we are using Spinner now. We then import it into App.tsx and add it to Suspense Fallback as a Component <code>Spinner /</code>. 
				</p>
				<p class="paragraph">
					<strong>Exercise: Chunk rest</strong>
					<br>
					We have routes in our ShopPage Component, therefore we will refactor them to use lazy and Suspense. Done. 
				</p>
				<a id="04" href="#00">Index</a>
				<h2 class="subtitle">Error Boundaries</h2>
				<p class="paragraph">
					YOu can wrap any Component in Lazy, however, save it for the larger Components that have a large tree under them. With Chunking we are depending on our network whenever a request is made because we need to fetch the chunk for that component from the server. If we lose that connection then our spinner will display indefinitely, to avoid this we need to create a <strong>Error Boudnary</strong>. This feature was introduced at the same time as Suspense. It works similarly to Suspense, however it catches an error and renders the Component in fallback instead of letting the error occur and break the page. 
				</p>
				<p class="paragraph">
					<strong>Creating ErrorBoundary</strong>
					<br>
					We create error-boundary/error-boundary.component.tsx and inside we import React. ErrorBoundaries <em>can only be Class Components</em> because we need access to lifecycle methods that are currently not replaceable with Hooks. We need internal state in this Component, we do <code>constructor(props: any) { super(props) ... }</code> where we set the state <code>this.state = { hasErrored: false, }</code> for which we create an interface and set the generic in our Component <code>any, ErrorBoundaryState</code> for TS support. This state will let us know if any of the child Components inside ErrorBoundary has produced an err or not. 
				</p>
				<p class="paragraph">
					<strong>lifecycle Methods</strong>
					<br>
					We use a lifecylce method <code>static getDerivedStateFromError(err: Error) { return { hasErrored: true }</code> this method gets the err if any of the children throw an error. What this method returns is what is set as the state locally, meaning the State for ErrorBoundary. Now that we have the error the Component knows that it has erred and we use <code>componentDidCatch(err:Error, errInfo: ErrorInfo) { ... }</code> where we can handle the err once the state has changed. We would send this to an err service. 
				</p>
				<p class="paragraph">
					<strong>render() and using</strong>
					<br>
					In our render we will use the internal state <code>return this.state.hasErrored ? ... : this.props.children</code> here we will return a div with Something went wrong in it if we have an err, if not we will render the child components without hinderance. We then export ErrorBoundary as the default. We import it into App.tsx and then wrap our Suspense Component in ErrorBoundary. Now if any of the lazy loading Components break or something happens to the network, we have a fallback component in our ErrorBoundary render(). We test by manually throwing an Err in HomePage, and we get our message displayed.
				</p>
				<p class="paragraph">
					<strong>Improving Component</strong>
					<br>
					We want to improve our message when something breaks, we do this by importing styles provided by Yihua and pasting them in error-boundary.styles.tsx. I had to use the generic to use imageUrl. We import in the 3 Styled Components into ErrorBoundary and then in our render() we return ErrorImageOverlay as the top Component, then <code>ErrorImageContainer imageUrl='...'</code> and the ErrorImageText underneath it. We then test it out and get a centered nice image with our error message. I went further and used the err message as well just to test out. Having done that we now have our Suspense Component and ErrorBoundary Component. 
				</p>
				<a id="05" href="#00">Index</a>
				<h2 class="subtitle">React.memo, PureComponent, shouldComponentUpdate</h2>
				<p class="paragraph">
					There are Component level optimizations. We go to our lifecycles component exercise and start by looking at <code>shouldComponentUpdate()</code>. This method would stop re-rendering if the current props match the props that we are bringing later. However, we can do this without using this method, and in a way that works with React.FC. Yihua creates a component that has a counter and a sub component called person. Even though person doesn't change, every time the counter changes, Person is re-rendered. We know this happens becasue when the top level component renders, every FC child is also re-rendered. We use the react dev-tools Profiler to see how long it takes to load things and we see that every click is costing 0.5ms in rendering Person unnecessarily. 
				</p>
				<p class="paragraph">
					<strong>React.memo()</strong>
					<br>
					In a React.FC we can use React.memo() to do a <em>shallow comparison</em> of state like shouldComponentUpdate() which will stop the re-rendering if the state doesn't change. We use it by wrapping it like a HOC <code>export default React.memo(Person)</code>. Now when we increase the count there is no re-rendering. We test using Profiler using memo() and not using it. React.memo() takes 0.2ms aprox to do it. Components that don't have props, dont use memo(). Measure to see if things are faster in the grand scheme of things. IMO having memo() is much better in the long run. 
					<strong>React.PureComponent</strong> works in Class Components. We can get the same effect by using <code>class ComponentName extends React.PureComponent</code> which will do the same we did with shouldComponentUpdate(), without having to write it. 
				</p>
				<p class="paragraph">
					<strong>Performance in our App</strong>
					<br>
					We test out what would happen if we kept the same things in Person using React.memo() but changed what we are passing as props to Person. We send in an inline instance of an object instead of the reference we have in our state. This causes us to re-render every time when using the count button even though the value doesn't change and we have the Component memoized. This happens because every time we run the code, JS creates a new Obj with a new reference in memory. Since we used Redux and reselect, we are covered from using React.memo(). This is optimized and has increased performance. 
				</p>
				<p class="paragraph">
					<strong>CartDropdown</strong>
					<br>
					Yihua uses the profiler and starts adding items to the Cart. We see that every item gets re-rendered when we send a new item to the cart, which is not optimal. This happens beacuse in our CartDropdown we are using an array <code>cartItems.map(...)</code> which will always trigger the new generation of CartItem Components. Our CartItem Component gets its props from the parent which gets them from Redux, however, it doesn't have any memoization. We wrap it in React.memo() and now we only re-render the item if it is new. That was a very handy optimization that was very easy. 
				</p>
				<a id="06" href="#00">Index</a>
				<h2 class="subtitle">useCallback and useMemo</h2>
				<p class="paragraph">
					
				</p>
			</li>
		</ul>
	</div>

	<!-- Optional JavaScript -->
	<!-- jQuery first, then Popper.js, then Bootstrap JS -->
	<script src="https://code.jquery.com/jquery-3.4.1.slim.min.js" integrity="sha384-J6qa4849blE2+poT4WnyKhv5vZF5SrPo0iEjwBvKU7imGFAV0wwj1yYfoRSJoZ+n" crossorigin="anonymous"></script>
	<script src="https://cdn.jsdelivr.net/npm/popper.js@1.16.0/dist/umd/popper.min.js" integrity="sha384-Q6E9RHvbIyZFJoft+2mJbHaEWldlvI9IOYy5n3zV9zzTtmI3UksdQRVvoxMfooAo" crossorigin="anonymous"></script>
	<script src="https://stackpath.bootstrapcdn.com/bootstrap/4.4.1/js/bootstrap.min.js" integrity="sha384-wfSDF2E50Y2D1uUdj0O3uMBJnjuUD4Ih7YwaYd1iqfktj0Uod8GCExl3Og8ifwB6" crossorigin="anonymous"></script>
	</body>
</html>