<!doctype html>
<html lang="en">
  	<head>
		<!-- Required meta tags -->
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

		<!-- Bootstrap CSS -->
		<link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.4.1/css/bootstrap.min.css" integrity="sha384-Vkoo8x4CGsO3+Hhxv8T/Q5PaXtkKtu6ug5TOeNV6gBiFeWPGFN9MuhOf23Q9Ifjh" crossorigin="anonymous">
		<style>
			code{
				background-color: rgba(0,0,0,.075);
				font-weight: bold;
			}
			.subtitle{
				font-size: 1.3rem;
				font-weight: bold;
				margin: 0;
				padding: 5px;
				margin-top: 5px;
				background-color: rgba(0,0,0,.075);
				text-align: center;
			}
			h3{
				font-size: 2rem;
				font-weight: bold;
				margin: 0;
				padding: 5px;
				margin-top: 10px;
			}
			.paragraph{
				margin: 0.5rem 0 0.5rem;
			}
			.tab{
				margin: 0 1rem;
			}
			html{
				scroll-behavior: smooth;
			}
			</style>

		<title>Advanced Redux and Firebase</title>
  	</head>
  	<body>
      
    <div class="container">
		<h1 class="display-3 text-center">Advanced Redux and Firebase<hr></h1>
		<header>	
			<p class="paragraph">
				Overall description.
			</p>
		</header>

		<h2 id="00" class="subtitle">Index</h2>
		<table class="table table-striped">
			<thead>
				<tr>
					<th scope="col">#</th>
					<th scope="col">Topic</th>
					<th scope="col">Description</th>
				</tr>
			</thead>
			<tbody>
				<tr>
					<th scope="row">1</th>
					<td>
						<a href="#01">topicName</a>
					</td>
					<td>
						<code>Code or description</code>
					</td>
				</tr>
			</tbody>
		</table>

		<ul class="list-group">
			<li class="list-group-item">
				<a id="01" href="#00">Index</a>
				<h2 class="subtitle">Moving our Shop Data to Firebase</h2>
				<p class="paragraph">
					The first videos of the module where review of Firestore. The most important parts are that Firestore is a DB that stores data in collections that have documents. And these documents can have collections of their own with documents and etc... Similar to how objects work, our collection would be a <em>key</em> and our documents are the <em>values</em>. <code>{ collection: value[ nestedCollection:  value[ ... ] ]}</code> etc... Another thing to note, is that documents on Firestore, don't have to follow a schema, meaning that different documents under the same collection can have different fields. This gives us flexibility, but may cause problems on front end interaction. 
				</p>
				<p class="paragraph">
					<strong>Firestore Types of Properties</strong>
					<br>
					We can store <em>number, boolean, map, array, null, timestamp, geopoint</em>. Map is a JSON that has a unique key. Arrays are like <em>maps</em> but the index (number) is the key. We want to create a collection from our codebase. 
				</p>
				<p class="paragraph">
					<strong>Setting our collections</strong>
					<br>
					We go to <strong>firebase.utils.js</strong> and create a new Fn <code>export const addCollectionAndDocuments = ( collectionKey, objectsToAdd ) => { const collectionRef = fitestore.collection(collectionKey); console.log(collectionRef) }</code> which we will use to create a new collection by passing the objects to it. We want to pass the shop collections, so we import a selector from <em>SHOP</em> in our mapStateToProps() <code>collectionsArray: selectCollectionsAsArray(state)</code> which will pass it to the props of App. We destructure it in our Component. Then, after our userAuth logic, we add it <code>addCollectionAndDocuments('collections;, collectionsArray)</code> and we can see it in our console, where we can see our collectionRef.
				</p>
				<p class="paragraph">
					<strong>passing the data</strong>
					<br>
					We go to firebase utils where we will do a <strong>batch write</strong>: a way to group all our calls together into one big requests. We want this because we want consistency, and this ensures that if one of our saves fails, the whole transaction will fail if it happens in the middle of saving. We use <code>const batch = firestore.batch()</code> which gives us the batch object. Then we want to loop through all the objects to add <code>objectsToAdd.forEach(obj=> { ... })</code>. Inside we <code>const newDocRef = collectionRef.doc()</code> which tells Firestore to give us a new document reference in the collection and generate a random id for it. Whatever we pass inside doc() will become the id, which we could do if we wanted. However, it is best to generate a random id that cannot collide with another name. Now, instead of doing <code>newDocRef.set()</code> like we did before, we will do <code>batch.set(newDocRef, obj)</code> which batch creates. After this Fn, we call <code>batch.commit()</code> We make our Fn async and <code>return await batch.commit()</code> which will only return if the whole batch of calls succeeds. 
				</p>
				<p class="paragraph">
					<strong>Data Considerations</strong>
					<br>
					Our data at the moment, holds values that we don't want in the db, like the routeName and the id because we are asking firestore to generate them for us. We do this in our App Component in addCollectionAndDocuments() <code>collectionsArray.map( ({ title, items }) => ({ title, items }) )</code> which will pass a new array with objects where title: title, and items: items. Now that we did this, we need to remove the code from the component so that we don't create the documents again. However, we have our util Fn to re-use if we need to add docs from the front end to the back end in the future. 
				</p>
				<a id="02" href="#00">Index</a>
				<h2 class="subtitle">Moving our Shop Data to Our App</h2>
				<p class="paragraph">
					We need to pull the data from Firestore, and then pass it into our reducer and storing it in our redux so that our app has access to it. We need to consider what part of the data we need for the Front-end and what we have in the backend. We removed parts of the data because we don't need it in the DB, now we need to create it for the front end again. Another consideration is in what part of our component tree we need to put this data and the code that fetches it. If we have two branches that need that data, we need to call the data and store it in the parent component of that tree so that we only have to fetch it once to pass it down both branches. 
				</p>
				<p class="paragraph">
					<strong>Shop Component</strong>
					<br>
					We want to have the state in our Shop Component, until now we have done it using a class component. I will attempt to do this using a FC instead of what Yihua does. I used <code>{ ... return( ... )}</code> to get JS access to our hooks. I read the docs and found that useEffect() is what replaces componentDidMount(). I did <code>useEffect(() => { ... })</code> where we create <code>const collectionRef = firestore.collection('collections')</code> which will fetch the collection snapShot from firebase. Then we <code>collectionRef.onSnapshot(async snapshot => { console.log(snapshot) })</code> to see what we get. We can see that we get a docs prop in the object that is an array of 5 items, that holds the id for each collection.
				</p>
				<p class="paragraph">
					<strong>Transforming the data</strong>
					<br>
					We will create a util Fn in our <strong>firebase.utils.js</strong> to handle this. We create <code>export const convertCollectionsSnapshotToMap = (collections) => { ... }</code> inside we create <code>const transformedCollection = collections.docs.map(doc => { ... } )</code> to get the data from the snapshot we need to call data() on the doc itself. We want to destructure what we need for our our frontend <code>const { title, items } = doc.data()</code> then we want to return our re-structured object <code>return{ routeName: encodeURI(title.toLoweCase()), ... }</code> encodeURI() is a JS method that converts all strings to a valid URI string by replacing invalid values with valid values. And we toLowerCase() to keep our routes standard when we use routeName to route. Then we do <code>{ ... id: doc.id, title, items }</code> which will return the object that we need. We add a console.log() to see it. We go to our shopComponent and in our collectionRef.onSnapshot() we call <code>convertCollectionsSnapshotToMap(snapshot)</code> which we can see returns an array of the objects structured as we need them to be. 
				</p>
				<a id="03" href="#00">Index</a>
				<h2 class="subtitle">Adding Shop Data to Redux</h2>
				<p class="paragraph">
					Now that we have our array, we need to set it to the structure we had <strong>normalized data</strong>. To do this we go to our util and do <code>return transformedCollection.reduce( ... , {})</code> where we have an empty object as a starting value. Then we <code>(accumulator, collection) => { accumulator[collection.title.toLowerCase()] = collection; return accumulator }</code> This will create a new key in our {} using the collection.title converted to lowecase, and then set the value to the object in the collection array. Then we return it to the next iteration of the reducer. 
				</p>
				<p class="paragraph">
					<strong>Updating the redux reducer</strong>
					<br>
					We go the types file and create <code>export const ShopActionTypes = { UPDATE_COLLECTIONS: 'UPDATE_COLLECTIONS' } as const</code> which will be used for our actions. Then we create a <strong>shop.actions.ts</strong> We import the types and create a new action: <code>export const updateCollections = ( collectionsMap: ShopMap ): ShopActions => ({ ... })</code> that required extensive re-typing and type creation in our types file. Inside we <code>type: ShopActionTypes.UPDATE_COLLECTIONS, payload: collectionsMap</code> that will return our action.
				</p>
				<p class="paragraph">
					<strong>Shop reducer & Shop Component</strong>
					<br>
					We type our reducer <code>const shopReducer: Reducer&lt;ShopState, ShopActions> = ( ... )</code> where we create a new case for our switch <code>case ShopActionTypes.UPDATE_COLLECTIONS: return { ...state, collections: action.payload }</code> which will create our new object that will be passed to the root reducer. Now that we have that set up, we need to use it in the shop Component where we need to use connect. Since we are passing an action we need to create our mapDispatchToProps(), then do our connector(), ConnectedProps generic, and finally wrap our component in connector(). Then we destructure our updateCollections() from the props so that we use the dispatch() version of our action, and everything is working. 
				</p>
			</li>
			<h2>Section 17 HOC Patterns</h2>
			<li class="list-group-item">
				<a id="04" href="#00">Index</a>
				<h2 class="subtitle">WithSpinner HOC</h2>
				<p class="paragraph">
					Since we are getting the data from the Backend, we don't need to use INITIAL_STATE or SHOP_DATA anymore. 
				</p>
			</li>
		</ul>
	</div>

	<!-- Optional JavaScript -->
	<!-- jQuery first, then Popper.js, then Bootstrap JS -->
	<script src="https://code.jquery.com/jquery-3.4.1.slim.min.js" integrity="sha384-J6qa4849blE2+poT4WnyKhv5vZF5SrPo0iEjwBvKU7imGFAV0wwj1yYfoRSJoZ+n" crossorigin="anonymous"></script>
	<script src="https://cdn.jsdelivr.net/npm/popper.js@1.16.0/dist/umd/popper.min.js" integrity="sha384-Q6E9RHvbIyZFJoft+2mJbHaEWldlvI9IOYy5n3zV9zzTtmI3UksdQRVvoxMfooAo" crossorigin="anonymous"></script>
	<script src="https://stackpath.bootstrapcdn.com/bootstrap/4.4.1/js/bootstrap.min.js" integrity="sha384-wfSDF2E50Y2D1uUdj0O3uMBJnjuUD4Ih7YwaYd1iqfktj0Uod8GCExl3Og8ifwB6" crossorigin="anonymous"></script>
	</body>
</html>