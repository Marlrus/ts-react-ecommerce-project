<!doctype html>
<html lang="en">
  	<head>
		<!-- Required meta tags -->
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

		<!-- Bootstrap CSS -->
		<link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.4.1/css/bootstrap.min.css" integrity="sha384-Vkoo8x4CGsO3+Hhxv8T/Q5PaXtkKtu6ug5TOeNV6gBiFeWPGFN9MuhOf23Q9Ifjh" crossorigin="anonymous">
		<style>
			code{
				background-color: rgba(0,0,0,.075);
				font-weight: bold;
			}
			.subtitle{
				font-size: 1.3rem;
				font-weight: bold;
				margin: 0;
				padding: 5px;
				margin-top: 5px;
				background-color: rgba(0,0,0,.075);
				text-align: center;
			}
			h3{
				font-size: 2rem;
				font-weight: bold;
				margin: 0;
				padding: 5px;
				margin-top: 10px;
			}
			.paragraph{
				margin: 0.5rem 0 0.5rem;
			}
			.tab{
				margin: 0 1rem;
			}
			html{
				scroll-behavior: smooth;
			}
			</style>

		<title>21 React Hooks</title>
  	</head>
  	<body>
      
    <div class="container">
		<h1 class="display-3 text-center">21 React Hooks<hr></h1>
		<header>
			<p class="paragraph">
				Overall description.
			</p>
		</header>

		<h2 id="00" class="subtitle">Index</h2>
		<table class="table table-striped">
			<thead>
				<tr>
					<th scope="col">#</th>
					<th scope="col">Topic</th>
					<th scope="col">Description</th>
				</tr>
			</thead>
			<tbody>
				<tr>
					<th scope="row">1</th>
					<td>
						<a href="#01">topicName</a>
					</td>
					<td>
						<code>Code or description</code>
					</td>
				</tr>
			</tbody>
		</table>

		<ul class="list-group">
			<li class="list-group-item">
				<a id="01" href="#00">Index</a>
				<h2 class="subtitle">useState()</h2>
				<p class="paragraph">
					Feb 2019 saw the start of hooks. It had a massive impact in the react community. It creates a different flow to what we have done until now. They emerged because the React Community found the lifecycle methods of Class Components confusing. The solution was hooks, which allow us to get functionality that was only available in Class Components in Functional Components. 
				</p>
				<p class="paragraph">
					<strong>useState()</strong>
					<br>
					useState() is a hook that returns two things that we get access to using array destructuring. Use state returns 2 paramenters that we access through destructuring: <code>const [state, setState] = useState()</code> The first one is the state value, and the second one is the Fn that we will use to set that state. What we pass to useState() is the initial value we want the state to have <code>useState(stateValue)</code> which will be stored in the <code>state</code> variable. 
				</p>
				<p class="paragraph">
					<strong>useState() limitations</strong>
					<br>
					In our class components we usually have a state object with multiple values, using useState() we would have to create a new useState() for each value that we want to alter. For example <code>const [address, setAddress] = useState('Bogota')</code> would set the initial address variable in our state to Bogota and we would change it with setAddress. However if we had more values in our state we would need to use the hook for each value. This is the prefered pattern, keeping different states for our different values.
				</p>
				<a id="02" href="#00">Index</a>
				<h2 class="subtitle">useEffect()</h2>
				<p class="paragraph">
					This hook gives us the ability to fire side effects in our React.FC. useEffect() does not get any value, instead, it takes a Fn that gets called whenever the component changes/renders. When we setState() using the useState() hook it will trigger useEffect() with default parameters because it will tirgger when the component updates and re-renders. If we want to fire it as componentDidMount() we pass a second parameter <code>useEffect(CB, [])</code> This array will take what our useEffect() hook uses as a reference to trigger. If we leave it empty it will only trigger on the mount, if we set <code>[state]</code> it will trigger when we change the state we get from useState(). We can create different triggers for useEffect(). 
				</p>
				<p class="paragraph">
					<strong>Fetching data</strong>
					<br>
					If we set the CB as an async Fn we get an error: <em>An effect function must not return anything besides a function, which is used for clean-up</em>. Instead we create our async Fn inside the CB <code>() => const fetchFn = async () => { ... }</code>. Inside we fetch and convert to JSON usually and setState() with the Fn from useState(). After we declare the Fn we need to call it in useEffect <code>fetchFn()</code> if we remove the [] second argument and use this method, our Fn triggers endlessly. This happens because we are setting the state with setState() which will tirgger a re-render, that will trigger useEffect() which will trigger setState() again and it creates the endless loop.
				</p>
				<p class="paragraph">
					If we are seaching data using a seachQuery we <code>[searchQuery]</code> as the second useEffect() argument, which will trigger only when the value of the searchQuery changes. The values inside this array should be the ones that we are using to trigger the CB inside useEffect(). 
				</p>
				<p class="paragraph">
					<strong>Hook Main Rule</strong>
					<br>
					Hooks cannot be called as a conditional, meaning that we cannot put them inside an if statement. The <strong>must always be called in the top level of our component</strong>. Therefore, if we want to leverage a conditional, we have to do this inside the hook. 
				</p>
				<a id="03" href="#00">Index</a>
				<h2 class="subtitle">Converting Class Components with useState()</h2>
				<p class="paragraph">
					We convert our SignIn component. We convert it into a FC <code>const SignIn: React.FC&lt;SignInProps&gt; = ({ googleSignInStart, emailSignInStart, }) => { ... }</code> which will destructure the props we pass it through our use of connect(). Then we remove the constructor, remove the render() and make a few changes. I had done this before, so I didn't see anything unexpected except in our handleChange() Fn <code>setCredentials({ ...userCredentials, [name]: value })</code> which we had without the destructured elements before. This is because hooks leverage pure Fns, and if we dont spread the existing credentials, we are not respecting the data integrity. I removed it as we had before and we got an err. After it was refactored, it worked just the same as before. 
				</p>
				<p class="paragraph">
					<strong>Sign Up Component</strong>
					<br>
					I will do this one on my own. I refactored exactly as yihua did and the component is working perfectly. 
				</p>
				<a id="04" href="#00">Index</a>
				<h2 class="subtitle">useEffect() in our App</h2>
				<p class="paragraph">
					As it stands we are using a class component in our App Component just for our componentDidMount() lifecycle method. We can replace it using useEffect(). I refactored it on my own. We set <code>[checkUserSession]</code> into the dependency array of our useEffect(), which will not cause any problems because this Fn wont change which wont trigger the hook, and React will small err if we don't since it is a dependency. 
				</p>
				<p class="paragraph">
					The other Component that Yihua had using componentDidMount() was the ShopPage Component, however, I did that one as an FC using hooks already. 
				</p>
				<a id="05" href="#00">Index</a>
				<h2 class="subtitle">useEffect() as ComponentDidUnmount()</h2>
				<p class="paragraph">
					In our app we aren't using this lifecycle method. Inside our useEffect() Fn we can return another Fn inside, this is called a clean-up Fn. This Fn is what useEfect() calls when the component unmounts. We would have used this with the observer pattern that we had in our auth before. This would be the purpose of this useEffect clean-up Fn. This is why the only return that can be had in the useEffect() hook is the clean up Fn. 
				</p>
				<a id="06" href="#00">Index</a>
				<h2 class="subtitle">Custom Hooks</h2>
				<p class="paragraph">
					Why would we want to have custom hooks? If we were to have some functionality that we share between components that use almost the same code and hooks, we could create our custom hook that merges the hook calls. In the example we were using useState() to set a user state, and useEffect() to do a fetch() API call that gets the user and in the other component a post. We create a new file that has this naming convention <code>hook-name.effect.js</code>. Here we create a Fn that encompasses fetching <code>const useFetch = (url) => { ... }</code> Where we will get the url to fetch from, and then use useState() and useEffect() inside that hook to call the API. We then import this into both of our components and pass the call and we have effectively written the two hooks once and used them in two different components. Custom hooks are just a way to combine multiple existing React Hooks for custom functionality.
				</p>
				<a id="07" href="#00">Index</a>
				<h2 class="subtitle">useReducer() Hook</h2>
				<p class="paragraph">
					We won't use it in our live application. This is beacause this hook leverages functionality that we are handling using Redux. This is basically the same data flow from redux but for the local state of a component. Similar to useState() we get two things back from useReducer <code>const [state. dispatch] = useReducer(reducer, INITIAL_STATE)</code> Here state is the state object that we are using, and dispatch is Fn that passes actions to our reducer. The reducer, is a Fn that we will create that takes a state and an action, and uses switch/case to return a state object (Just like every reducer we have done in Redux already). The second parameter is the initial state, just like Redux. 
				</p>
				<p class="paragraph">
					In our Component file we then proceed to create our INITIAL_STATE and the reducer with our cases and default return. Then we have to create the actions individually in this file as well as we had in our Redux workflow. The real difference comes in how we use this reducer, dispatch, and actions. We destructure the values from the state <code>const { value1, value2 } = state</code>, and then we dispatch the appropriate actions. We go into our component, and the Fn calls we have we will wrap in a dispatch <code>dispatch(Fn1(param))</code>, now when the Fn gets triggered, it will trigger an action and dispatch the action to the reducer() which will then alter the state. 
				</p>
				<p class="paragraph">
					useReducer() is just a native implementation of Redux where you have complex state handling in a component. However, there is no root reducer meaning the the state is not global.
				</p>
				<p class="paragraph">
					<strong>Should you use hooks</strong>
					<br>
					There is massive hype around hooks, and React has moved towards the use of hooks over the use of class components. Migrating from Redux and lifecycle methods to hooks is very unlikely, especially on code bases that have already been set up. Yihua disagrees with the migration to hooks because users try to mimic the effects of lifecycle methods with hooks, and he thinks that if we want lifecycle methods we should just use them because they are there. Some libraries like React Router, have also implemented hooks. Before we used the withRouter() HOC to access the history and other props we get from router, whereas now you can pull it with the useHistory() hook <code>let history = useHistory()</code> and then <code>function handleClick() { history.push('/home') }</code> which we could do in our component directly. 
				</p>
				<p class="pargraph">
					Moving away from HOC after you app uses a lot of HOC is not that simple of an undertaking. Redux also implement hooks, the useSelector() hook will let us select parts of our state just like we did with the <strong>reselect</strong> library. Before we had our selectors in our <strong>name.selectors.ts</strong> file, which we passed to the component using mapStateToProps(), which can now be done locally using redux hooks. Another caveat is that we might be faced with problems in memoizing our selectors with reselect if we create them inline using our hooks. 
				</p>
			</li>
		</ul>
	</div>

	<!-- Optional JavaScript -->
	<!-- jQuery first, then Popper.js, then Bootstrap JS -->
	<script src="https://code.jquery.com/jquery-3.4.1.slim.min.js" integrity="sha384-J6qa4849blE2+poT4WnyKhv5vZF5SrPo0iEjwBvKU7imGFAV0wwj1yYfoRSJoZ+n" crossorigin="anonymous"></script>
	<script src="https://cdn.jsdelivr.net/npm/popper.js@1.16.0/dist/umd/popper.min.js" integrity="sha384-Q6E9RHvbIyZFJoft+2mJbHaEWldlvI9IOYy5n3zV9zzTtmI3UksdQRVvoxMfooAo" crossorigin="anonymous"></script>
	<script src="https://stackpath.bootstrapcdn.com/bootstrap/4.4.1/js/bootstrap.min.js" integrity="sha384-wfSDF2E50Y2D1uUdj0O3uMBJnjuUD4Ih7YwaYd1iqfktj0Uod8GCExl3Og8ifwB6" crossorigin="anonymous"></script>
	</body>
</html>