<!doctype html>
<html lang="en">
  	<head>
		<!-- Required meta tags -->
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

		<!-- Bootstrap CSS -->
		<link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.4.1/css/bootstrap.min.css" integrity="sha384-Vkoo8x4CGsO3+Hhxv8T/Q5PaXtkKtu6ug5TOeNV6gBiFeWPGFN9MuhOf23Q9Ifjh" crossorigin="anonymous">
		<style>
			code{
				background-color: rgba(0,0,0,.075);
				font-weight: bold;
			}
			.subtitle{
				font-size: 1.3rem;
				font-weight: bold;
				margin: 0;
				padding: 5px;
				margin-top: 5px;
				background-color: rgba(0,0,0,.075);
				text-align: center;
			}
			h3{
				font-size: 2rem;
				font-weight: bold;
				margin: 0;
				padding: 5px;
				margin-top: 10px;
			}
			.paragraph{
				margin: 0.5rem 0 0.5rem;
			}
			.tab{
				margin: 0 1rem;
			}
			html{
				scroll-behavior: smooth;
			}
			</style>

		<title>Advanced Redux and Firebase</title>
  	</head>
  	<body>
      
    <div class="container">
		<h1 class="display-3 text-center">Advanced Redux and Firebase<hr></h1>
		<header>	
			<p class="paragraph">
				Overall description.
			</p>
		</header>

		<h2 id="00" class="subtitle">Index</h2>
		<table class="table table-striped">
			<thead>
				<tr>
					<th scope="col">#</th>
					<th scope="col">Topic</th>
					<th scope="col">Description</th>
				</tr>
			</thead>
			<tbody>
				<tr>
					<th scope="row">1</th>
					<td>
						<a href="#01">topicName</a>
					</td>
					<td>
						<code>Code or description</code>
					</td>
				</tr>
			</tbody>
		</table>

		<ul class="list-group">
			<li class="list-group-item">
				<a id="01" href="#00">Index</a>
				<h2 class="subtitle">Moving our Shop Data to Firebase</h2>
				<p class="paragraph">
					The first videos of the module where review of Firestore. The most important parts are that Firestore is a DB that stores data in collections that have documents. And these documents can have collections of their own with documents and etc... Similar to how objects work, our collection would be a <em>key</em> and our documents are the <em>values</em>. <code>{ collection: value[ nestedCollection:  value[ ... ] ]}</code> etc... Another thing to note, is that documents on Firestore, don't have to follow a schema, meaning that different documents under the same collection can have different fields. This gives us flexibility, but may cause problems on front end interaction. 
				</p>
				<p class="paragraph">
					<strong>Firestore Types of Properties</strong>
					<br>
					We can store <em>number, boolean, map, array, null, timestamp, geopoint</em>. Map is a JSON that has a unique key. Arrays are like <em>maps</em> but the index (number) is the key. We want to create a collection from our codebase. 
				</p>
				<p class="paragraph">
					<strong>Setting our collections</strong>
					<br>
					We go to <strong>firebase.utils.js</strong> and create a new Fn <code>export const addCollectionAndDocuments = ( collectionKey, objectsToAdd ) => { const collectionRef = fitestore.collection(collectionKey); console.log(collectionRef) }</code> which we will use to create a new collection by passing the objects to it. We want to pass the shop collections, so we import a selector from <em>SHOP</em> in our mapStateToProps() <code>collectionsArray: selectCollectionsAsArray(state)</code> which will pass it to the props of App. We destructure it in our Component. Then, after our userAuth logic, we add it <code>addCollectionAndDocuments('collections;, collectionsArray)</code> and we can see it in our console, where we can see our collectionRef.
				</p>
				<p class="paragraph">
					<strong>passing the data</strong>
					<br>
					We go to firebase utils where we will do a <strong>batch write</strong>: a way to group all our calls together into one big requests. We want this because we want consistency, and this ensures that if one of our saves fails, the whole transaction will fail if it happens in the middle of saving. We use <code>const batch = firestore.batch()</code> which gives us the batch object. Then we want to loop through all the objects to add <code>objectsToAdd.forEach(obj=> { ... })</code>. Inside we <code>const newDocRef = collectionRef.doc()</code> which tells Firestore to give us a new document reference in the collection and generate a random id for it. Whatever we pass inside doc() will become the id, which we could do if we wanted. However, it is best to generate a random id that cannot collide with another name. Now, instead of doing <code>newDocRef.set()</code> like we did before, we will do <code>batch.set(newDocRef, obj)</code> which batch creates. After this Fn, we call <code>batch.commit()</code> We make our Fn async and <code>return await batch.commit()</code> which will only return if the whole batch of calls succeeds. 
				</p>
				<p class="paragraph">
					<strong>Data Considerations</strong>
					<br>
					Our data at the moment, holds values that we don't want in the db, like the routeName and the id because we are asking firestore to generate them for us. We do this in our App Component in addCollectionAndDocuments() <code>collectionsArray.map( ({ title, items }) => ({ title, items }) )</code> which will pass a new array with objects where title: title, and items: items. Now that we did this, we need to remove the code from the component so that we don't create the documents again. However, we have our util Fn to re-use if we need to add docs from the front end to the back end in the future. 
				</p>
				<a id="02" href="#00">Index</a>
				<h2 class="subtitle">Moving our Shop Data to Our App</h2>
				<p class="paragraph">
					We need to pull the data from Firestore, and then pass it into our reducer and storing it in our redux so that our app has access to it. We need to consider what part of the data we need for the Front-end and what we have in the backend. We removed parts of the data because we don't need it in the DB, now we need to create it for the front end again. Another consideration is in what part of our component tree we need to put this data and the code that fetches it. If we have two branches that need that data, we need to call the data and store it in the parent component of that tree so that we only have to fetch it once to pass it down both branches. 
				</p>
				<p class="paragraph">
					<strong>Shop Component</strong>
					<br>
					We want to have the state in our Shop Component, until now we have done it using a class component. I will attempt to do this using a FC instead of what Yihua does. I used <code>{ ... return( ... )}</code> to get JS access to our hooks. I read the docs and found that useEffect() is what replaces componentDidMount(). I did <code>useEffect(() => { ... })</code> where we create <code>const collectionRef = firestore.collection('collections')</code> which will fetch the collection snapShot from firebase. Then we <code>collectionRef.onSnapshot(async snapshot => { console.log(snapshot) })</code> to see what we get. We can see that we get a docs prop in the object that is an array of 5 items, that holds the id for each collection.
				</p>
				<p class="paragraph">
					<strong>Transforming the data</strong>
					<br>
					We will create a util Fn in our <strong>firebase.utils.js</strong> to handle this. We create <code>export const convertCollectionsSnapshotToMap = (collections) => { ... }</code> inside we create <code>const transformedCollection = collections.docs.map(doc => { ... } )</code> to get the data from the snapshot we need to call data() on the doc itself. We want to destructure what we need for our our frontend <code>const { title, items } = doc.data()</code> then we want to return our re-structured object <code>return{ routeName: encodeURI(title.toLoweCase()), ... }</code> encodeURI() is a JS method that converts all strings to a valid URI string by replacing invalid values with valid values. And we toLowerCase() to keep our routes standard when we use routeName to route. Then we do <code>{ ... id: doc.id, title, items }</code> which will return the object that we need. We add a console.log() to see it. We go to our shopComponent and in our collectionRef.onSnapshot() we call <code>convertCollectionsSnapshotToMap(snapshot)</code> which we can see returns an array of the objects structured as we need them to be. 
				</p>
				<a id="03" href="#00">Index</a>
				<h2 class="subtitle">Adding Shop Data to Redux</h2>
				<p class="paragraph">
					Now that we have our array, we need to set it to the structure we had <strong>normalized data</strong>. To do this we go to our util and do <code>return transformedCollection.reduce( ... , {})</code> where we have an empty object as a starting value. Then we <code>(accumulator, collection) => { accumulator[collection.title.toLowerCase()] = collection; return accumulator }</code> This will create a new key in our {} using the collection.title converted to lowecase, and then set the value to the object in the collection array. Then we return it to the next iteration of the reducer. 
				</p>
				<p class="paragraph">
					<strong>Updating the redux reducer</strong>
					<br>
					We go the types file and create <code>export const ShopActionTypes = { UPDATE_COLLECTIONS: 'UPDATE_COLLECTIONS' } as const</code> which will be used for our actions. Then we create a <strong>shop.actions.ts</strong> We import the types and create a new action: <code>export const updateCollections = ( collectionsMap: ShopMap ): ShopActions => ({ ... })</code> that required extensive re-typing and type creation in our types file. Inside we <code>type: ShopActionTypes.UPDATE_COLLECTIONS, payload: collectionsMap</code> that will return our action.
				</p>
				<p class="paragraph">
					<strong>Shop reducer & Shop Component</strong>
					<br>
					We type our reducer <code>const shopReducer: Reducer&lt;ShopState, ShopActions> = ( ... )</code> where we create a new case for our switch <code>case ShopActionTypes.UPDATE_COLLECTIONS: return { ...state, collections: action.payload }</code> which will create our new object that will be passed to the root reducer. Now that we have that set up, we need to use it in the shop Component where we need to use connect. Since we are passing an action we need to create our mapDispatchToProps(), then do our connector(), ConnectedProps generic, and finally wrap our component in connector(). Then we destructure our updateCollections() from the props so that we use the dispatch() version of our action, and everything is working. 
				</p>
			</li>
			<h2>Section 17 HOC Patterns</h2>
			<li class="list-group-item">
				<a id="04" href="#00">Index</a>
				<h2 class="subtitle">WithSpinner HOC</h2>
				<p class="paragraph">
					Since we are getting the data from the Backend, we don't need to use INITIAL_STATE or SHOP_DATA anymore. We then go to INITIAL_STATE and <code>collections: null</code>, which will cause errs. We have to fix our selector <code>selectCollectionsAsArray()</code> so that it can handle a null object, we do <code>collections => collections ? convertToArray(collections) : null</code> which fixes one of our issues. The other issue is with our selectCollecion selector, which also expects an object. Here we need to <code>collections ? collections[collectionUrlParam] : null</code>, which removes the err. Now the components that use this selector will explicitly use null and know that there is no data being passed, rendering an empty state if needed. 
				</p>
				<p class="paragraph">
					<strong>Loading State Err</strong>
					<br>
					We get an err from our CollectionPage Component because it is expecting a property title and items from collection that it is not getting before the data is fetched from Firestore. What we want to do is render a spinner of some kind while the data is being fetched. We will create a <strong>Spinner Component</strong> that uses the HOC pattern we have used before. We create the folder and styles. Copy in the styles for our styled-component. We import SpinnerOverlay and SpinnerContainer: The overlay ensures that our spinner is always centered. We then create <code>const WithSpinner = (WrappedComponent: React.FC) => ({ isLoading, ...otherProps}) => { ... }</code> where we will pass an isLoading boolean to determine what we return. Inside we do <code>return isLoading ? ( ... ) : ( ... )</code> Where we return SpinnerOverlay with SpinnerContainer as a child if we are loading, and our <code>WrappedComponent { ...otherProps }</code> if we aren't.
				</p>
				<p class="paragraph">
					<strong>Where to place WithSpinner Logic and Component</strong>
					<br>
					We place the logic inside our ShopPage because it is the one that handles the updating of our collections. It knows when the data is being loaded, and when it is finshed loading through our Fn. We import WithSpinner and then we go to our component. Here Yihua uses state = ... but since we are using an FC that uses hooks we do <code>const [loading, setLoading] = useState({loading: true})</code> which will set the state to that object. setLoading() is a Fn that will update the state. In our useEffect() hook we place <code>setLoading({ loading: false })</code> right after updateCollections which will set loading in our state to false. 
				</p>
				<p class="paragraph">
					I had some errors with the WithSpinner HOC, I had to use different typing <code>WrappedComponent: React.ComponentType&lt;any></code> in order to get it to work. This is less than ideal. Then I went back to the ShopPage component and <code>const CollectionsOverviewWithSpinner = WithSpinner(CollectionsOverview)</code> and the same for CollectionPage. Then we go into our route component and change the component={...} prop to <code>render={(props) => ( ... )}</code> Where we render inside <code>CollectionsOverviewWithSpinner isLoading={loading} {...props}</code> Which takes the state we set with useState(). Here I had to destructure it <code>const { loading } = loadingState;</code> that comes from <code> const [loadingState, setLoading] = useState({ loading: true });</code> And we do the same thing for CollectionPageWithSpinner. Now when we go to any of the paths and refresh the page, we will see the spinner display while the content is being loaded. In second thought, having the generic ANY doesn't affect the logic in our components becasue this isLoading prop is temporary and we are not wrapping our component in our new WithSpinner HOC. We can now use this HOC whenever we need to do async fetching. 
				</p>
				<a id="05" href="#00">Index</a>
				<h2 class="subtitle">Optional: How to build HOCs</h2>
				<p class="paragraph">
					The HOC is a very common pattern in the React Ecosystem. We will write our Own. A HOC is just a component that takes in another component and returns a new enhanced one, just like we do with Connect. 
				</p>
			</li>
		</ul>
	</div>

	<!-- Optional JavaScript -->
	<!-- jQuery first, then Popper.js, then Bootstrap JS -->
	<script src="https://code.jquery.com/jquery-3.4.1.slim.min.js" integrity="sha384-J6qa4849blE2+poT4WnyKhv5vZF5SrPo0iEjwBvKU7imGFAV0wwj1yYfoRSJoZ+n" crossorigin="anonymous"></script>
	<script src="https://cdn.jsdelivr.net/npm/popper.js@1.16.0/dist/umd/popper.min.js" integrity="sha384-Q6E9RHvbIyZFJoft+2mJbHaEWldlvI9IOYy5n3zV9zzTtmI3UksdQRVvoxMfooAo" crossorigin="anonymous"></script>
	<script src="https://stackpath.bootstrapcdn.com/bootstrap/4.4.1/js/bootstrap.min.js" integrity="sha384-wfSDF2E50Y2D1uUdj0O3uMBJnjuUD4Ih7YwaYd1iqfktj0Uod8GCExl3Og8ifwB6" crossorigin="anonymous"></script>
	</body>
</html>