<!doctype html>
<html lang="en">
  	<head>
		<!-- Required meta tags -->
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

		<!-- Bootstrap CSS -->
		<link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.4.1/css/bootstrap.min.css" integrity="sha384-Vkoo8x4CGsO3+Hhxv8T/Q5PaXtkKtu6ug5TOeNV6gBiFeWPGFN9MuhOf23Q9Ifjh" crossorigin="anonymous">
		<style>
			code{
				background-color: rgba(0,0,0,.075);
				font-weight: bold;
			}
			.subtitle{
				font-size: 1.3rem;
				font-weight: bold;
				margin: 0;
				padding: 5px;
				margin-top: 5px;
				background-color: rgba(0,0,0,.075);
				text-align: center;
			}
			h3{
				font-size: 2rem;
				font-weight: bold;
				margin: 0;
				padding: 5px;
				margin-top: 10px;
			}
			.paragraph{
				margin: 0.5rem 0 0.5rem;
			}
			.tab{
				margin: 0 1rem;
			}
			html{
				scroll-behavior: smooth;
			}
			</style>

		<title>00 Your Name Here</title>
  	</head>
  	<body>
      
    <div class="container">
		<h1 class="display-3 text-center">00 Your Name Here<hr></h1>
		<header>
			<p class="paragraph">
				Overall description.
			</p>
		</header>

		<h2 id="00" class="subtitle">Index</h2>
		<table class="table table-striped">
			<thead>
				<tr>
					<th scope="col">#</th>
					<th scope="col">Topic</th>
					<th scope="col">Description</th>
				</tr>
			</thead>
			<tbody>
				<tr>
					<th scope="row">1</th>
					<td>
						<a href="#01">topicName</a>
					</td>
					<td>
						<code>Code or description</code>
					</td>
				</tr>
			</tbody>
		</table>

		<ul class="list-group">
			<li class="list-group-item">
				<a id="01" href="#00">Index</a>
				<h2 class="subtitle">Routing in React</h2>
				<p class="paragraph">
					SPA: We send a single page once, a single JS file, and a single CSS file. The JS file manipulate the DOM and fetch the data in JSON. This server can be used to send data to any source, meaning we only need one server. The downside is that we have a bigger JS file. When SPAs started there was a problem with the back button. Since there was no changing of the URL in a page, there was no way to use it because the browser would have nowhere to navigate back to. We use React Router to mimic URLs and have this functionality in SPA.
				</p>
				<p class="paragraph">
					<strong>Routing in our Project</strong>
					<br>
					The package <code>react-router-dom</code> is the most widely used React routing package with the most support. We install it with <code>yarn add react-router-dom</code> I also install <code>yarn add @types/react-router-dom</code>. We do <code>import { BrowserRouter } from 'react-router-dom'</code> which gives us access the the BrowserRouter component, and we wrap it around our App component. We then go to our App component and <code>import { Route } from 'react-router-dom'</code> which will give us access to the Route component. This component takes 3 props <code>exact path component</code> component refers to the Component that we will render, path is the URL that will trigger the rendering, and exact takes a true or false value (true by default). <strong>exact</strong> will make it so that the component is only rendered when the exact URL is there, if it is not set at all it will default to false, which means that any URL that has the <em>path</em> as part of the URL will also be rendered. 
				</p>
				<p class="paragraph">
					<strong>Switch Component</strong>
					<br>
					We import another component <code>Swtich</code>, we wrap that around our Route. We create a temporary component HatsPage that renders an H1. Here we set that Route to path '/hats'. If we run the code without exact we will render both HomePage and HatsPage. If we wrap it inside Switch, it will render the first match it finds and not render the other Component. If we don't have exact, we will have a match when using /hats for both '/' and '/hats', since '/' is matched first, it will not render our HatsPage component. The match happens from top-down order, if I place '/hats' Route over the '/' routes, it will render the HatsPage. Switch gives us a bit more control in knowing that we will only render one page as intended if the Router matches it.  
				</p>
				<a id="02" href="#00">Index</a>
				<h2 class="subtitle">React Router Dom</h2>
				<p class="paragraph">
					<strong>match prop</strong>
					We want to see the inner workings of our Route component, so we set a console.log for props and load our page to see what gets passed to our component from Route. We can see that the 3 props that got passed were: history, location, and match in an Object. Inside <strong>match</strong> we get 4 things: isExact, params {}, path, url. The <strong>url</strong> prop will only show us the URL path up to where it matched, so in the case that we don't set exact, we will render this page on every path, but this prop will still be '/'. The <strong>path</strong> prop will show us the pattern that the route is looking to match (what we pass in Route). The <strong>isExact</strong> prop will be true only if the patter that we are matching is exact to the one in the browser URL, and is what we use to render if we set exact in Router. The <strong>params</strong> prop is an object of URL parameters, which is what we do in Node with <code>:_id</code> which means that it will match up to a point and then will recieve a dyanic param to match something. If we have <code>path='/hats:hat_id'</code> and navigate to thet route we will see <code>params: { hat_id: "13" }</code> and <code>path: "/hats:hat_id"</code> and <code>url: "/hats/13"</code> and <code>isExact: true</code> which shows us the nature of the 4 params better. 
				</p>
				<p class="paragraph">
					<strong>history prop</strong>
					<br>
					This is a far more complicated object, we want to focus on <code>push</code>. There are two ways to navigate in React, we have been dynamically updating the URL and going to diff pages. The first way to travel is using the Link component. The Link component is from react router that takes one prop <code>to='/path'</code> and works like an A tag. Router is an SPA, so it just highjacks the URL position to determine what to render or unmount. Using A would redirect us and force the re-render of the entire application, whereas Link just borrows the URL to tell React what to re-render. The other way to do this navigation is to use the <strong>history</strong> prop. If we wanted to navigate with a button instead of a Link, we would use an onClick event <code>button onClick={()=> props.history.push('/topics')}</code> which is equivalet to using a Link but gives us more dynamic access. We could use <code>props.history.push(...)</code> in any function execution of our app without having to render a Link, for example in componentDidMount. 
				</p>
				<p class="paragraph">
					<strong>location prop</strong>
					<br>
					the <strong>location</strong> props tells us where we are currently. The main prop here is <strong>pathname</strong> which will show us were we are in the URL regardless of what is rendered in the app. This prop can be accessed to allow our components to be aware of the exact location the URL has at the moment. 
				</p>
				<p class="paragraph">
					<strong>The match prop and Nested Routing</strong>
					<br>
					We leverage the <strong>match</strong> prop to have a nested route structure. If one of our components renders out a bunch of Link components we can use a dynamically generated <strong>to</strong> prop <code>Link to={`${props.match.url}/13`</code> and we can have multiple of these to different links. Now it doesn't matter <em>where</em> our Component is, it will <em>always</em> know how to take us to that URL, even if we altar the path that renders that component in our Route component. Now all of our links won't care about any path before where it matched, and will be able to navigate to where we want to go even if we make changes in our routing. This also enables us to re-use Components that use different routing to go to different parts of our SPA. 
				</p>
				<a id="02" href="#00">Index</a>
				<h2 class="subtitle">withRouter()</h2>
				<p class="paragraph">
					There is a caveat in using the pops passed down from our Route component. Only the component that was rendered using the Route component gets access to the props passed down from Route. One solution is to pass these props down to our children components. I spent about 30 minutes trying to solve a TS problem doing prop tunneling or prop drilling, which is a bad practice. But I found the types xD. We passed the props from homepage all the way down to menu-item, but this is not good because none of the children need history other than menu-item. I undid all the work I did... then proceeded to the better solution. 
				</p>
				<p class="paragraph">
					<strong>withRouter</strong>
					<br>
					We import a component <code>import { withRouter } from 'react-router-dom'</code>. This is a higher-order component, a Fn that takes a component as an argument and returns a modified component. 
				</p>
			</li>
		</ul>
	</div>

	<!-- Optional JavaScript -->
	<!-- jQuery first, then Popper.js, then Bootstrap JS -->
	<script src="https://code.jquery.com/jquery-3.4.1.slim.min.js" integrity="sha384-J6qa4849blE2+poT4WnyKhv5vZF5SrPo0iEjwBvKU7imGFAV0wwj1yYfoRSJoZ+n" crossorigin="anonymous"></script>
	<script src="https://cdn.jsdelivr.net/npm/popper.js@1.16.0/dist/umd/popper.min.js" integrity="sha384-Q6E9RHvbIyZFJoft+2mJbHaEWldlvI9IOYy5n3zV9zzTtmI3UksdQRVvoxMfooAo" crossorigin="anonymous"></script>
	<script src="https://stackpath.bootstrapcdn.com/bootstrap/4.4.1/js/bootstrap.min.js" integrity="sha384-wfSDF2E50Y2D1uUdj0O3uMBJnjuUD4Ih7YwaYd1iqfktj0Uod8GCExl3Og8ifwB6" crossorigin="anonymous"></script>
	</body>
</html>