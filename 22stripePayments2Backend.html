<!doctype html>
<html lang="en">
  	<head>
		<!-- Required meta tags -->
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

		<!-- Bootstrap CSS -->
		<link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.4.1/css/bootstrap.min.css" integrity="sha384-Vkoo8x4CGsO3+Hhxv8T/Q5PaXtkKtu6ug5TOeNV6gBiFeWPGFN9MuhOf23Q9Ifjh" crossorigin="anonymous">
		<style>
			code{
				background-color: rgba(0,0,0,.075);
				font-weight: bold;
			}
			.subtitle{
				font-size: 1.3rem;
				font-weight: bold;
				margin: 0;
				padding: 5px;
				margin-top: 5px;
				background-color: rgba(0,0,0,.075);
				text-align: center;
			}
			h3{
				font-size: 2rem;
				font-weight: bold;
				margin: 0;
				padding: 5px;
				margin-top: 10px;
			}
			.paragraph{
				margin: 0.5rem 0 0.5rem;
			}
			.tab{
				margin: 0 1rem;
			}
			html{
				scroll-behavior: smooth;
			}
			</style>

		<title>Stripe Payments P2: Backend</title>
  	</head>
  	<body>
      
    <div class="container">
		<h1 class="display-3 text-center">Stripe Payments P2: Backend<hr></h1>
		<header>
			<p class="paragraph">
				Overall description.
			</p>
		</header>

		<h2 id="00" class="subtitle">Index</h2>
		<table class="table table-striped">
			<thead>
				<tr>
					<th scope="col">#</th>
					<th scope="col">Topic</th>
					<th scope="col">Description</th>
				</tr>
			</thead>
			<tbody>
				<tr>
					<th scope="row">1</th>
					<td>
						<a href="#01">topicName</a>
					</td>
					<td>
						<code>Code or description</code>
					</td>
				</tr>
			</tbody>
		</table>

		<ul class="list-group">
			<li class="list-group-item">
				<a id="01" href="#00">Index</a>
				<h2 class="subtitle">Intro to Backend</h2>
				<p class="paragraph">
					We are going to write our backend in Node to allow us to finish processing our stripe payments. Due to SPAs we have decoupled from what the front end and backend are. Before, we made a request to an endpoint in a server and that would get data from the server, and it would send back all of the HTML, CSS, and JS of the page depending on the HTTP request we sent. With SPA we hit a single route, and it sends one big bundle of HTML, CSS, and JS, and processes the page in the browser without getting the page from the server, depending on how we set up the react app. 
				</p>
				<p class="paragraph">
					We still need the backend to hold our data, and to hide env variables. API Application Programming Interface. It is different URLs or endpoints that we can hit for different things. The server determines what to do when we send a request to the server. We have already done this for the Admin Platform that I developed.
				</p>
				<a id="02" href="#00">Index</a>
				<h2 class="subtitle">Creating our Server Inside the Project</h2>
				<p class="paragraph">
					We create a new dir client/ in our project folder. Then we move everything into this client folder. <code>mv ./* ./client</code> git DID NOT like this. We need to create a new package.json file in this root dir for the new dependencies, and a server.ts file. We copy and paste the contents of our <strong>package.json</strong> from the resources in the course. 
				</p>
				<p class="paragraph">
					<strong>Scripts</strong>
					<br>
					We have the standard package.json things but we also have some pre-set scripts. The <strong>client</strong> script will cd into client && yarn start there. This will replace yarn start. The <strong>server</strong> script will use nodemon to run server.ts. We have <strong>build</strong> which cd client && npm run build. <strong>dev</strong> is how we run our server and client in one single terminal. We do this through a package in our dev dependencies called <strong>concurrently</strong>. It has a flag <code>--kill-others-on-fail</code> which means that if one of our project sides breaks, the other will break as well. We have <strong>start</strong> which will run node server.js which we have here for heroku, which will look for a start script. The we have <code>heroku-postbuild</code> which is a script that heroku will run after it finishes building. It will cd into client/ and npm install, and then run npm install, and we have a <code>--no-shrinkwrap</code> flag which means that we won't lock in the versions. And finally we run npm run build which will build our client build folder. 
				</p>
				<p class="paragraph">
					<strong>Dependencies</strong>
					<br>
					We have the body-parser lib, which we have used extensively, which converts our requests into JSON automatically. We have <strong>cors</strong> which handles cross origin requests. We have <strong>dotenv</strong> which we have used before to store secret keys. Then we have <strong>express</strong> to write our node backend easily. <strong>stripe</strong> is the library to process our payments. Then we will run yarn. We then set a new area in our package <code>"engines": { "node": "nodeVersionNumber", "npm": "npmVersionNumber" },</code> 
				</p>
				<a id="03" href="#00">Index</a>
				<h2 class="subtitle">Building a Basic Server</h2>
				<p class="paragraph">
					Since I am using TS, I had to do a few extra steps. I ran <code>tsc --init</code> to get a tsconfig.json file and modified it to the setup I had in my other node TS file. I had to add items to exclude: node_modules and client beacuase TSC was insisting on compiling all the files iniside the client/ that had our React app. This fixed it but tsconfig still errs because it wants all the ts files in the src/ dir. I also had to -D install the @types for express, cors, and node. 
				</p>
				<p class="paragraph">
					<strong>Base Setup</strong>
					<br>
					We start with 4 imports: express, cors, bodyParser, and path (Native JS). Path lets us build out pathing for our directories which helps with pathing on optimized builds. We then <code> if (process.env.NODE_ENV !== 'production') require('dotenv').config()</code> I don't see the point in this so I just require normally. Then we <code>const port = process.env.PORT || 5000;</code> to have our server run on a different port to our react app. In our <strong>client/package.json</strong> we <code>"proxy": "http://localhost:5000"</code> will make CRA know to use that as a URL when calling URLs in the app. We then <code>app.use(bodyParser.json())</code> which will tell bodyParser to convert all our requests to JSON. Then we <code>app.use(bodyParser.urlencoded({ extended: true }));</code> which will remove all invalid characters from URL string automatically.  
				</p>
				<p class="pargraph">
					Then we <code>app.use(cors());</code> which allows us to handle <strong>cross origin requests</strong>. Our app is hosted on port 3000, while our server is on 5000, therefore it is in a different origin. When our app calls our server, cors checks if our port is the same, if it is not, it denies the request. This line of code enables us to do these requests from different porst without getting a CORS error message. We then <code>if (process.env.NODE_ENV === 'production') { ... }</code> which will use <code>app.use(express.static(path.join(__dirname, 'client/build')));</code> which tells our app to use the express.static() middleware Fn. This Fn allows us to serve a certain file inside of the URL that we pass to it. The path uses our <strong>path</strong> library which uses the join() to create the URL using <code>__dirname</code> which tells us what directory we are currently in (This is a part of Node.js), and we point to <code>'client/build</code>. This is what guets built when we run our build script in our package.json. 
				</p>
				<p class="paragraph">
					Once we have that, we will do <code>app.get('*', (req,res)=> { ... })</code> which will trigger get() on any URL that the user hits. Inside we <code>res.sendFile(path.join(__dirname, 'client/build', 'index.html'))</code> which returns the index.html file in our client/build that holds all of our front end client code: HTML, CSS, JS. This is how we will server our app in our production build. Then we set the code to start the server <code>app.listen(port, () => console.log(`Server running on port ${port}`));</code> Here, yihua has an err, where he passes a second object err to the CB, however this does not exist in app.listen(). Thanks to TS we caught this, and we can handle err appropriately <code>app.listen(...).on('error', (err) => { throw err });</code>
				</p>
				<a id="04" href="#00">Index</a>
				<h2 class="subtitle">Backend Payment Route</h2>
				<p class="paragraph">
					We want to create a route for stripe we create <code>app.post('/payment', ...=>{ ... })</code> as usual where we create a post route that we will trigger in the frontend. We will create a <code>const body = { ... }</code> that we will send to the stripe API, using our req.body. We then import the stripe library and call it using <code>const tripe = new stripeImport(process.env.STRIPE_SECRET_KEY)</code> which will give us back the stripe object that we can use to make charges. Then in our route we do <code>stripe.charges.create(body, CB)</code> The CB is a FN that has 2 parameters, err and value. The error is handled if we get an error from our req, the value is the respones we get from stripe. I had to TS type them using the d.ts file <code>(err: IStripeError, response: charges.ICharge)</code>.
				</p>
				<p class="paragraph">
					In the Fn we perform a ternary operator <code>if(err) ? res.status(500).send({ error: err }) : res.status(200).send({ success: response })</code> which is our whole route. Having our backend set, we now need to write the code to connect both sides.
				</p>
				<a id="05" href="#00">Index</a>
				<h2 class="subtitle">Connecting Client to Server</h2>
				<p class="paragraph">
					We run <code>yarn dev</code> which runs our client app and server at the same time. We then go to our client/ dir and install axios <code>yarn add axios</code>. This library will replace our native JS fetch() as it is a lib that can handle more complex fetch requests. Since we are in client/ this will put it in the client package.json file.
				</p>
				<p class="paragraph">
					<strong>StripeButton Component</strong>
					<br>
					In our component we will change our onToken() Fn. We import axios. In our <code>const onToken = (token: Token) => { ... }</code> we erase the content and add an <em>AxiosRequestConfig</em> object: <code>axios({ url: 'payment', method: 'post', data: { amount: priceForStripe, token, } })</code> This will make a POST request to /payment (Axios infers the URL based on what we set in our package.json) which triggers our backend route, and sends a data object with the amount expected by stripe, and the token. 
				</p>
				<p class="paragraph">
					That response is what we expect in our backend, where we take the token and the ammount to pass it to stripe.charges.create(). 
				</p>
			</li>
		</ul>
	</div>

	<!-- Optional JavaScript -->
	<!-- jQuery first, then Popper.js, then Bootstrap JS -->
	<script src="https://code.jquery.com/jquery-3.4.1.slim.min.js" integrity="sha384-J6qa4849blE2+poT4WnyKhv5vZF5SrPo0iEjwBvKU7imGFAV0wwj1yYfoRSJoZ+n" crossorigin="anonymous"></script>
	<script src="https://cdn.jsdelivr.net/npm/popper.js@1.16.0/dist/umd/popper.min.js" integrity="sha384-Q6E9RHvbIyZFJoft+2mJbHaEWldlvI9IOYy5n3zV9zzTtmI3UksdQRVvoxMfooAo" crossorigin="anonymous"></script>
	<script src="https://stackpath.bootstrapcdn.com/bootstrap/4.4.1/js/bootstrap.min.js" integrity="sha384-wfSDF2E50Y2D1uUdj0O3uMBJnjuUD4Ih7YwaYd1iqfktj0Uod8GCExl3Og8ifwB6" crossorigin="anonymous"></script>
	</body>
</html>