<!DOCTYPE html>
<html lang="en">
   <head>
      <!-- Required meta tags -->
      <meta charset="utf-8" />
      <meta
         name="viewport"
         content="width=device-width, initial-scale=1, shrink-to-fit=no"
      />

      <!-- Bootstrap CSS -->
      <link
         rel="stylesheet"
         href="https://stackpath.bootstrapcdn.com/bootstrap/4.4.1/css/bootstrap.min.css"
         integrity="sha384-Vkoo8x4CGsO3+Hhxv8T/Q5PaXtkKtu6ug5TOeNV6gBiFeWPGFN9MuhOf23Q9Ifjh"
         crossorigin="anonymous"
      />
      <style>
         code {
            background-color: rgba(0, 0, 0, 0.075);
            font-weight: bold;
         }
         .subtitle {
            font-size: 1.3rem;
            font-weight: bold;
            margin: 0;
            padding: 5px;
            margin-top: 5px;
            background-color: rgba(0, 0, 0, 0.075);
            text-align: center;
         }
         h3 {
            font-size: 2rem;
            font-weight: bold;
            margin: 0;
            padding: 5px;
            margin-top: 10px;
         }
         .paragraph {
            margin: 0.5rem 0 0.5rem;
         }
         .tab {
            margin: 0 1rem;
         }
         html {
            scroll-behavior: smooth;
         }
      </style>

      <title>00 Your Name Here</title>
   </head>
   <body>
      <div class="container">
         <h1 class="display-3 text-center">
            00 Your Name Here
            <hr />
         </h1>
         <header>
            <p class="paragraph">
               Overall description.
            </p>
         </header>

         <h2 id="00" class="subtitle">Index</h2>
         <table class="table table-striped">
            <thead>
               <tr>
                  <th scope="col">#</th>
                  <th scope="col">Topic</th>
                  <th scope="col">Description</th>
               </tr>
            </thead>
            <tbody>
               <tr>
                  <th scope="row">1</th>
                  <td>
                     <a href="#01">topicName</a>
                  </td>
                  <td>
                     <code>Code or description</code>
                  </td>
               </tr>
            </tbody>
         </table>

         <ul class="list-group">
            <li class="list-group-item">
               <a id="01" href="#00">Index</a>
               <h2 class="subtitle">Sidequest: Prettier</h2>
               <p class="paragraph">
						It stupidly took me forever to set up prettier. All I neede for what I wanted was to install <code>yanr add -D prettier</code> and configure a <strong>.prettierrc</strong> file with my settings. I got it going and now I have it after 2 hours + ... I created a <strong>.prettierignore</strong> file with <code>*.html</code> in it for stopping it from formatting this document...
					</p>
					<a id="02" href="#00">Index</a>
               <h2 class="subtitle">Firebase Intro</h2>
               <p class="paragraph">
						We will use Firebase for Auth and Storage. Firebase is a backend tool (Database, Server, Auth) for things that the user doesn't see. The DB is where we store the data that is important for the App, and that we want to preserve. The server stores the code that requests the data in the most efficient way possible. Auth is the way in which the server knows that the person requesting the data is the one that has persmission to get that data or that we need to send them some data like their cart info by default. Firebase handles all of this for us, meaning we need no backend code if we don't want to. Firebase is created by Google, and takes care of all the backend code for us. It has a ton of functionality that allows frontend developers to use backend features. 
					</p>
					<a id="02" href="#00">Index</a>
               <h2 class="subtitle">Adding a Project to Firebase</h2>
               <p class="paragraph">
						We go to the firebase page, login to our Google account and go to console. There we create a new project. Firebase offers a free "spark" plan, that we will rarely go over, and if we do it is not expensive at all. In the develop panel, we can see the things we have access to: Auth, DB, Storage, Hosting, Functions, ML Kit. We go to Auth. We go to Proeject Overview and click on Web. There we get prompted with some data, and we copy the JS Object we see. We then <code>yarn add firebase</code> 
					</p>
					<p class="paragraph">
						<strong>Setup</strong>
						<br>
						We create a dir firebase/ and a <strong>firebase.utils.js</strong> file for our config. The confing is the JS object we copied, if we lost it we just go to our firebase console, to the grid where it says app, then the setting of our app, and we scroll down to our app. There we see a CDN with a few script tags, we copy the contests of the <code>var firebaseConfig = { ... }</code> We go to our firebase.utils.js file and <code>import firebase from 'firebase/app'</code> Here we then <code>import 'firebase/firestore'</code> and <code>import 'firebase/auth'</code> and then <code>const config = { ... }</code> where we paste what we copied from the config object. Then we do <code>firebase.initiaizeApp(config)</code>. 
					</p>
					<p class="paragraph">
						<strong>Other exports and settings</strong>
						<br>
						We export <code>export const auth = firebase.auth()</code> and <code>export const firestore = firebase.firestore()</code>, this givves us access to anything related to auth and firestore if we need it in the future. We then proceed to set up our auth <code>const provider = new firebase.auth.GoogleAuthProvider()</code> which creates an object from the auth library with for Google. We then use that object and <code>provider.setCustomParameters({ propt: 'select_account' })</code> this means that we always want to trigger the google popup whever we use the GoogleAuthProvider for Auth and Sign-in. Then we <code>export const signInWithGoogle = () => auth.signInWithPopup(provider)</code> which uses a method from the auth object, but sets it to the google popup instead of the other possible popups. Then we <code>export default firebase</code> if we want to use more generic things from the firebase/app module. <strong>Note:</strong> Firebase is massive, it took 136.6s to install. 
					</p>
					<p class="paragraph">
						<strong>Configuring our Auth in Firebase and our Component</strong>
						<br>
						We go to the AUthetication tab, Sign-in providers and look for Google, then edit with the pencil icon on the right and enable it by giving it our email. Now it is officially enabled. We go into our SignIn Component and import <code>signInWithGoogle</code> and create a new CustomButton Component. Inside we add the <code>onClick={signInWithGoogle}</code> prop, we add it to the props of our element, and then we put Sign in with Google. We now have a button. I click it and I get a popup but I don't get prompted to choose a google account. 
					</p>
					<a id="03" href="#00">Index</a>
               <h2 class="subtitle">Google Sign In Auth 2</h2>
               <p class="paragraph">
						I had an err, my enabling of the Google Auth in the Firebase Console didn't go through, therefore I could not execute it. I fixed it and now the popup works as it should. I can now see the user in the Firebase account. <strong>Note:</strong> Seeing this part showed me that this course was done in May 17, 2019. We <code>import { auth } from './firebase/firebase.utils'</code>, now we want to store the user object in our state to use throughout our app. Since we need to store this in the state, we conver App to a class Component. We move all of our render logic into the render() method, and then we call the constructor with super() and <code>this.state = { currentUser: null }</code>
					</p>
					<p class="paragraph">
						We add a componentDidMount() method to handle the change of the auth state. Inside we use <code>auth.onAuthStateChanged((user)=> { ... })</code> where we set the state using the user <code>this.setState({ currentUser: user })</code> and we add a console.log(user) to see the user in our console. We get a very fucked up user object here. Our session data persists even if we reset the server, which is a setting htat can be handled in Firebase, but we get it here easy. I wanted to see how Firebase was storing the info in my browser, so I went to the console Application and checked at cookies, local storage, and session storage, but found nothing. Then I looked in IndexedDb and I see <code>firebaseLocalStorageDB</code> which has a fireBaseLocalStorage element inside, which oddly enough has my firebase API key, which is bizzare. However this is apparently not a risk, much like the google calendar API key. 
					</p>
					<p class="paragraph">
						<strong>Open Subscription</strong>
						<br>
						Its an open messaging system between our app and firebase. Whenever any change from any source realted to our app changes in Firebase it sends a message that the auth state has changed. Such as having signed in to our service, or they signed out. This connection is always open when our App component is mounted on our DOM. Since its an open subscription we have to close it when the component unmounts because we don't want a memory leak. We create a new method on our class <code>unsubscribeFromAuth: null | Function = null</code> which will be null by default. In our componentDidMount() we <code>this.unsubscribeFromAuth = auth.onAuthStateChanged( ... )</code> which will override our null default. Then to close the subscription we call <code>componentWillUnmount() { this.unsubscribeFromAuth() }</code> which will call our method when the app closes. <strong>Note:</strong> I don't really understand this auth flow at all, and have yet to find an article talking about this that uses the terminology that Yihua uses. This is how our App will get notified on any auth change on firebase. 
               </p>
               <a id="04" href="#00">Index</a>
               <h2 class="subtitle">Google Sign In Auth 3</h2>
               <p class="paragraph">
                  We will focus on how to sign out. We start by making our header aware of when a user is singed in, or signed out with the current user state. We pass it as a prop for Header <code>currentUser={this.state.currentUser}</code> which will err TS, because we have no props on Header, or type on the App State. I create <code>interface AppState { currentUser: null | object }</code> that will do for the meantime, I then pass the generic to the class component <code>any, AppState</code> the first one being the props which I am yet to understand so I set to any, the second one being the structure of the State. 
               </p>
               <p class="paragraph">
                  <strong>Header Component</strong>
                  <br>
                  I added <code>interface HeaderProps { currentUser: null | object }</code> and passed it as a generic to the FC <code>HeaderProps</code>, which allows me to destructure the props <code>({ currentUser })</code> which I will now use to conditinally render a SIGN IN or SIGN OUR button. Under our last Link component we use <code>{ currentUser? ... : ... }</code> that will return true if the currentUser in the state is an object, or not set to null. On the first condition we render a div with className option, and <code>onClick={()=> auth.signOut()}</code> which means we must import the auth library from our firebase utils. Now when we click this div it will log ous out. If we don't have a user, we wull render a Link component with SIGN IN, that has the same className option, and <code>to='/signin/</code> which will take us to our sign-in page. Now we can log in and log out using the user state. 
               </p>
               <p class="paragraph">
                  <strong>Props to manage CustomButton Style</strong>
                  <br>
                  We want to have our Google Sign In button to have its own style. To do this we can pass a prop to our button that will work to change the className and therefore add a style. We want to use a boolean on our CustomButton inside our SignIn component. we do <code>isGoogleSignIn</code>, if we leave it like that it will send down a value of true. In my CustomButton component I add this to the Props interface <code>isGoogleSignIn?: boolean</code> and I then pass it to the props we have destructured. Now we use the ternary operator to display a new class <code>`custom-button ${ isGoogleSignIn? 'google-sign-in' : '' }`</code> which will mean that we will always have the custom-button class, but if we pass the isGoogleSign in prop we will also have google-sign-in. Now we open our styles and add <code>&.google-sign-in { ... }</code> where we set the background to google blue and text to white. Then we add a <code>&:hover { ... }</code> nested in here so that the backgorund gets darker when we hover over and the border is removed. 
               </p>
               <p class="paragraph">
                  <strong>Styling</strong>
                  <br>
                  Now we go to our sign-in component and create a div around the buttons with className button. In the signIn styles we change the width to a fixed 380px and then nest the <code>.button { ... }</code> where we set the display to flex, and justify content to space-between which will separate the elements to the edge of the div. We have everything styled corerctly, but our inputs go slightly beyond the width we set for our component. This is due to <code>box-sizing</code>. This is a CSS property that is set in every browser, where our border, margin, and padding affect the overall size of our component. When we inspect the input, we can see that the green and blue part of the component goes beyond the orange margin that uses the container. We can change this in our App.css with <code>* { box-sizing: border-box }</code> which uses the universal selectior <em>all elements</em>. Now our elements are inline because the margin, padding, and border do not affect the element size, which we can actually see when we inspect the element. 
               </p>
               <a id="05" href="#00">Index</a>
               <h2 class="subtitle">Firebase Firestore</h2>
               <p class="paragraph">
                  We need to create a db in firestore. We do this in the database tab which takes us to a menu where we can click create database. Once that is done, we can choose a mode, locked mode that doesn't allow anyone to read or write in our DB, and test mode which allows everyone to write on it. We will start with test mode and then add additional rules to the db later. When we create it we can set Data, Rules, Indexes, and see Usage. Firestore is a NoSQL db that stores in JSON. We have collections: A group of objects that contains Documents. Just like MongoDB. We manually create a users collection, create a unique ID directly, and add a display_name field. Now we can see the doc in our firestore. Firestore uses the id as what we use to select the doc. 
               </p>
               <p class="paragraph">
                  <strong>Nested Collections</strong>
                  <br>
                  Inside our user document, we can also add a collection. We add cart_items to this document, and then we create a document with the name anchovies. Now we have a collection of documents inside our document. We can have many docs inside the collection of the same doc. 
               </p>
               <p class="paragraph">
                  <strong>Querying Firestore Data</strong>
                  <br>
                  We exported firestore in our utils. We call our collection with <code>firestore.collection('users')</code> and we target our doc with the id <code>firestore.collection('users').doc(...idValue...)</code> which would select our targetted document inside the users collection. We can keep chaining as much as we want. This is very different to mongoDB and I can see why it is hard to translate firestore data to mongoDB. We can also query a doc as if we were navigating a fs <code>firestore.doc('/users/idValue/cart_items/idValue')</code> which would fetch the doc that matches our ID for the path we created. We could do the same for a collection <code>firestores.collection('/users/idValue/cart_items')</code> which would return the whole cart_items collection. 
               </p>
               <a id="06" href="#00">Index</a>
               <h2 class="subtitle">Storing User Data in Firebase</h2>
               <p class="paragraph">
                  Right now, we have the users in firebase, however these are not in our database, firebase has them in its own, separate, space. We go to our firebase utils file and create a Fn to handle this. In Firestore there are two things: QueryReference and QuerySnapshot. When we make a query as we saw earlier, the response we get is a QueryReference, which can come as a Document or Collection. The <strong>queryReference</strong> object is an obj that represents the "current" place in the db that we are querying. 
               </p>
               <p class="paragraph">
                  <strong>queryReference</strong>
                  <br>
                  We create a dummy query that looks for a user Doc that doesn't exist. We then import it into our App Component and call our <code>createUserProfileDocument(user)</code> in our async onAuthStateChanged(). We then open our app and see that we get an object back. It has the dummy id we set, and the path that we also set. We are always getting back an object, even though it doesn't exist in our db. This is because the queryReference object is what we use to tell firebase to fetch or save data to the db. It doesn't have the actuall data, it has props that tell us details about it, or the method to get the Snapshot obj which gives us the data. We can also see in the <em>parent</em> prop we can see the CollectionReference that tells us where this document would be or is. 
               </p>
               <p class="paragraph">
                  <strong>DocumentReference vs CollectionReference</strong>
                  <br>
                  we use documentRef objects to perform our CRUD methods. The documentRef methods are set(), get(), update(), delete(). get() gets a snapshotObject of the data. We can also use add() to add docs to a collection using the collectionRef obj. We save the userRef to a const in our utils method, and then we call get() on it and log it. We can see that it has a prop <code>exists: false</code> that tells us that this doc is not in the db. 
               </p>
               <p class="paragraph">
                  <strong>Seeing if the user exists</strong>
                  <br>
                  We change the code to use string interpolation to use the uid from our google user object to see if we have the user in our firestore db <code>const userRef = firestore.doc(`users/${userAuth.uid}`)</code> which we use to get a snapshot and see if the user is in the db or not. We still get exists false, but we have the id as the actual id from our user obj. Now we want to add the user to the DB. 
               </p>
               <p class="paragraph">
                  <strong>Adding user to DB</strong>
                  <br>
                  We create <code>if(!snapShot.exists){ ... }</code> and inside we want to see what props from this object we want to store in the db. Since the snapShot doesn't handle CRUD operations, we need to use the userRef we stored before. We first get the props we want from our userAuth obj <code>const { displayName, email } = userAuth</code> and we add <code>const createdAt = new Date()</code>. Then we create a try catch block, and inside we use userRef with the set() method <code>await userRef.set({ displayName, email, createdAt, ...additionalData })</code> And if there is an err we log the err.message. Now if we don't have a user, we will create one. In the end we <code>return userRef</code> in case we want to do any CRUD operations to our user once the user is logged in. Now if we look in our Firebase db we can see our created user document with the fields we set. If we refresh our Fn will fire every time because auth is always persisting, we are still not creating multiple users becasue we detect an existing user and just return userRef. 
               </p>
               <a id="07" href="#00">Index</a>
               <h2 class="subtitle">Storing User Data in Our App</h2>
               <p class="paragraph">
                  We need to alter a Firestore Rule in order to perform CRUD opeartions, because by default, Firebase now disallows altering the DB for 30 days after creation. We remove the if statement and just leave <code>allow read, write;</code> Now that we have our createUserProfileDocument() method going, we also want to include that in our state. We got our App COmponent and alter our auth method a bit. We change user to userAuth, because that is more specific to the object that we are getting. Then we check if we have that object and store userRef <code>if(userAuth){ ... }</code> inisde <code>const userRef = await createUserProfileDocument(userAuth)</code> which is what we had set up earlier, that in the end the Fn returns the userRef. Then we call <code>userRef?.onSnapshot(snapShot=> { ... })</code> which will return a snapShot object.
               </p>
               <p class="paragraph">
                  <strong>Snapshot Object</strong>
                  <br>
                  We get it from our documentReference object. It allows us to check if a doc exists at this query with the <em>exists</em> prop (boolean). And it also allows us to get props of the object by calling the data() method, which returns a JSON obj of the document. We get NO data until we use the data() method. If we <code>console.log(snapShot.data())</code> in our onSnapshot method, we can see the data from our user as it is in Firestore. However, we can see that we <em>don't</em> have the id. Since we want both in the state we do <code>this.setState({ currentUser: { id: snapShot.id, ...snapShot.data() }</code> which will get the id from snapShot and then spread the props of our doc into the state.
               </p>
               <p class="paragraph">
                  Now, since this will fire every time our component gets mounted, we want to handle when we don't have a user, so we do an else statement <code>if (userAuth) { ... } else { this.setState({ currentUser: userAuth })</code> which will be null in this case, because if we get a userAuth obj we run the rest of the code, meaning that our script will only get here if userAtuh is null, setting the current user to null. 
               </p>
               <a id="08" href="#00">Index</a>
               <h2 class="subtitle">SignUp Component</h2>
               <p class="paragraph">
                  We create a new component SignUp. We do the default, but we import FormInput and CustomButton, as we will be using them here. Then we will import auth and createUserProfileDocument from our firebase utils. We create a class component <code>class SignUp extends React.Component { ... }</code> we do the basic but then create the state <code>this.state = { displayName: '', email: '', password: '', confirmPassword: '', }</code> which we then make an interface for. We pass the generic to the component <code>any, SignUpState</code> then we create a render() where we destructure the state <code>const { displayName, email, password, confirmPassword, } = this.state</code> Then we <code>return ( ... )</code> an H2 a Span and our Form className sign-up-form and with <code>onSubmit={this.handleSubmit}</code> which we haven't created. Then we create 4 FormInput components for our displayName, email, password, and confirmPassword. They vary slightly, and use <code>onChange={this.handleChange}</code> which we haven't created yet and makes TS angry... 
               </p>
               <p class="paragraph">
                  <strong>handleSubmit</strong>
                  <br>
                  We create our handleSubmit() method <code>handleSubmit = async (event: React.FormEvent<HTMLFormElement>) => { ... }</code> where we start with event.preventDefault() and then we destructure the state. We first check <code>if(password !== confirmPassword) return alert('Passwords don't match`) }</code> which will exit our Fn. If we continue, we use a try catch block. Inside we take the user from a method from our auth library <code>const { user } = await auth.createUserWithEmailAndPassword( email, password )</code> which uses our destructured state. Then we use our method <code>await createUserProfileDocument(user, {displayName})</code> and then we reset the state to empty values. Here we are destructuring displayName form the argument additionalData of our custom method. This will override the displayName since we don't get it from the user object, because this user doesn't come with data like the Google one. 
               </p>
               <p class="paragraph">
                  <strong>handleChange()</strong>
                  <br>
                  We create <code>handleChange = (event: React.ChangeEvent<HTMLInputElement>) => { ... }</code> where we use the event.target to get the values to give the state <code>const { name, value } = event.target</code> which we then <code>this.setState({ [name]: value })</code> which sets a dynamic prop name to the state. I added it to the interface with <code>[name: string]: string</code> to stop TS errs. We then add the basic styling and we are done here.
               </p>
               <a id="08" href="#00">Index</a>
               <h2 class="subtitle">Sign Up with Email and Password</h2>
               <p class="paragraph">
                  We add styles to our page for sign in and sign up and we should have both forms side by side. I had a slight problem where the style was not catching, and the mistake was that I had misspelled the className for the div and it was not applying the style set in the scss file. Changed that and had everything working. We test it out and we get the expected validation behaviour including passwords not matching. Then we get everything right and we get an error <code>auth/operation-not-allowed</code> because we haven't enabled this auth in Firebase.
               </p>
               <p class="paragraph">
                  <strong>Firebase Setup Local Auth</strong>
                  <br>
                  We go to our Firebase Auth tab and enable email/password. We don't want to have the email verification step for testing. And now we should be able to do this. Now I create the user and I can see that I am actually Moerse. Now we have our path set up.
               </p>
               <a id="09" href="#00">Index</a>
               <h2 class="subtitle">Sign In with Email and Password</h2>
               <p class="paragraph">
                  We import auth form firebase.utils and then we go to our handleSubmit() method. We turn it into an async method and then <code>{ email, password } = this.state</code> which we will pass to an auth method we place inside a try catch block <code>await auth.signInWithEmailAndPassword(email, password)</code>. And if that succeeds we will clear our state with the code we had previously. <strong>Note:</strong> As of now, even if we do sign in with google, we get prompted to add the email to the signin, however, we can change the behvaiour by setting the button to <code>type='button'</code> because HTML treats any button inside a form as type submit by default. This way we can override that behaviour. 
               </p>
               <p class="paragraph">
                  <strong>Review</strong>
                  <br>
                  We have to enable auth on firebase, once that is done we need to do some basic setup to implement it. If we leave it on default, we have auth stored in firebase outside of our DB. We need to create paths for our Firestore to save that data if the user is new, and retrieve it if the user is returning. Once we have that data, we need to set it to the state of the front-end so that we can update the page relative to the user that is currently browsing the app. Allowing us to handle the shopping cart, and special information so that they can have a proper shopping experience. 
               </p>
            </li>
         </ul>
      </div>

      <!-- Optional JavaScript -->
      <!-- jQuery first, then Popper.js, then Bootstrap JS -->
      <script
         src="https://code.jquery.com/jquery-3.4.1.slim.min.js"
         integrity="sha384-J6qa4849blE2+poT4WnyKhv5vZF5SrPo0iEjwBvKU7imGFAV0wwj1yYfoRSJoZ+n"
         crossorigin="anonymous"
      ></script>
      <script
         src="https://cdn.jsdelivr.net/npm/popper.js@1.16.0/dist/umd/popper.min.js"
         integrity="sha384-Q6E9RHvbIyZFJoft+2mJbHaEWldlvI9IOYy5n3zV9zzTtmI3UksdQRVvoxMfooAo"
         crossorigin="anonymous"
      ></script>
      <script
         src="https://stackpath.bootstrapcdn.com/bootstrap/4.4.1/js/bootstrap.min.js"
         integrity="sha384-wfSDF2E50Y2D1uUdj0O3uMBJnjuUD4Ih7YwaYd1iqfktj0Uod8GCExl3Og8ifwB6"
         crossorigin="anonymous"
      ></script>
   </body>
</html>
