<!doctype html>
<html lang="en">
  	<head>
		<!-- Required meta tags -->
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

		<!-- Bootstrap CSS -->
		<link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.4.1/css/bootstrap.min.css" integrity="sha384-Vkoo8x4CGsO3+Hhxv8T/Q5PaXtkKtu6ug5TOeNV6gBiFeWPGFN9MuhOf23Q9Ifjh" crossorigin="anonymous">
		<style>
			code{
				background-color: rgba(0,0,0,.075);
				font-weight: bold;
			}
			.subtitle{
				font-size: 1.3rem;
				font-weight: bold;
				margin: 0;
				padding: 5px;
				margin-top: 5px;
				background-color: rgba(0,0,0,.075);
				text-align: center;
			}
			h3{
				font-size: 2rem;
				font-weight: bold;
				margin: 0;
				padding: 5px;
				margin-top: 10px;
			}
			.paragraph{
				margin: 0.5rem 0 0.5rem;
			}
			.tab{
				margin: 0 1rem;
			}
			html{
				scroll-behavior: smooth;
			}
			</style>

		<title>28 Progressive Web App</title>
  	</head>
  	<body>
      
    <div class="container">
		<h1 class="display-3 text-center">28 Progressive Web App<hr></h1>
		<header>
			<p class="paragraph">
				Overall description.
			</p>
		</header>

		<h2 id="00" class="subtitle">Index</h2>
		<table class="table table-striped">
			<thead>
				<tr>
					<th scope="col">#</th>
					<th scope="col">Topic</th>
					<th scope="col">Description</th>
				</tr>
			</thead>
			<tbody>
				<tr>
					<th scope="row">1</th>
					<td>
						<a href="#01">topicName</a>
					</td>
					<td>
						<code>Code or description</code>
					</td>
				</tr>
			</tbody>
		</table>

		<ul class="list-group">
			<li class="list-group-item">
				<a id="01" href="#00">Index</a>
				<h2 class="subtitle">Progressive Web App</h2>
				<p class="paragraph">
					A webApp is a web page that allows users to interact with the web page in many ways. They are always are in a browser windows. A native app is that it is meant to work on a native app in an Android or iPhone. PWA addresses the want to have web apps function as close to native as possible without having to be native. For a web app you just need HTML, CSS, and JS, for a native App you need a different programming language. Native apps work by leveraging the files that are present on a user's phone. The apps have the files living on the phone instead of what we do with web apps that serve the apps from a web page. Native apps can also send you push notifications and work offline and you never get a blank screen, as you would if you don't have internet and are browsing the web. Native apps are also found in the App and Play Store, something that you cannot do with a web app, as well as the use of the functionality of a phone such as camera. 
				</p>
				<p class="paragraph">
					<strong>PWA</strong>
					<br>
					With PWA you can make apps work more like native apps. You can remove the URL bar, you can have an icon in the homescreen of the phone seemlessly. PWAs can work offline, can send push notifications, and can work faster on phones as well. The goal is to make them as similar to native as possible. It is easier to implement than it sounds and the updates are easier as you just need to update your server. With the App store you need to submit the changes and have an audit for the changes. The best part of all is that it runs on every platform available. The goal is better UX, websites. With HTML5 APIs we have more access to hardware, which we can see in <a href="https://whatwebcando.today">What Web Can Do Today</a> allowing us to know what we can do in a PWA regarding Hardware such as local notifications, push messages, audio and video capture, recording media, offline storage, geolocation, etc. 
				</p>
				<p class="paragraph">
					Google created PWA, and the slowest adopter is Apple due to business interests. Google has a massive browser and web share, apple has their closed App store ecosystem which locks you into using what Apple wants you to use and paying them for the App store app. Facebook has React Native, which is a way to build apps for native using react. Since apple is using their proprietary safari browser, they have been slow to adopt these changes out of self interest. This is a cosntant battle that will continue. PWAs will evolve over time and they enhance the UX in an easy way. It is beneficial for anyone that can do it. This is why CRA comes pre-set with PWA capabilities. With a few tweaks we can have a PWA pretty fast, there is no reason not to implement it. Google created Lighthouse which is a plugin that gives us some stats on performance and also shows us how close we are to PWA status. 
				</p>
				<p class="paragraph">
					<strong>PWA Examples</strong>
					<br>
					You can explore some of the top PWAs at <a href="https://appsco.pe/">Appscope</a>. Twitter has adopted to a PWA using React for every device from desktop, to native. Uber uses PWA, and Lyft is moving to PWA as well. There are tons of companies adopting PWAs like Starbucks too. Turning off the internet will not hinder the PWA from working, which is a huge plus for UX. If we go to a PWA and open the console and go into Application, we can see that there is a Manifest file, if we go there there is a link to <em>Add to homescreen</em>, which will appear to mobile users automatically if you visit the site. If you accept it, it will be added to your device as any other app would be added. If you then turn off your internet connection and oppen the App, it will still load. 
				</p>
				<a id="02" href="#00">Index</a>
				<h2 class="subtitle">The 3 Requirements</h2>
				<p class="paragraph">
					<strong>Requirement 1: HTTPS</strong>
					<br>
					PWAs have a checklist that can be seen on the <a href="https://web.dev/pwa-checklist/">Progressive Web App Checklist</a> from Google. These can change in the future but are the good practices for a good PWA. Instead of focusing on all of those things we can focus on the the main three things, as CRA covers the other ones pretty well: <strong>HTTPS, App Manifest, Service Worker</strong>. HTTPS prevents bad actors from tampering with communications between our app and our browser. Messages are encrypted and travel like that to our server, meaning that if the message is intercepted it cannot be understood. Any time data is sent from the data to the server you NEED HTTPS. PWA require HTTPS for security reasons that are more strict. Github pages has HTTPS encription automatically. If you want to host somewhere else, your best bet is to use <a href="https://letsencrypt.org/">Let's Encrypt</a> which is <em>A nonprofit Certificate Authority providing TLS certificates to 225 million websites.</em> These services make browsers know that you are who you say you are and in this page are free. 
				</p>
				<p class="paragraph">
					There are also services like <a href="https://www.cloudflare.com/">Cloudflare</a> which is a CDN. They are a server to put your files on, similar to Heroku. Our app is going to work with every feature for HTTPS out of the box because we are using github pages. 
				</p>
				<p class="paragraph">
					<strong>Requirement 2: App Manifest</strong>
					<br>
					For a PWA to work like a native app, we need to imitate the shell of the mobile app. We do this through the App Manifest. For the file to work, you need to add a meta tag with name viewport and the PWA settings in it, it is a must have for PWA functionality. If we use CRA we can go to public/manifest.json which holds all the information of how the app should appear to the user in places where users expect to see apps. CRA comes with its own favicon, however we have a bunch of missing files that appear in the manifest file. To create our own favicon we can use <a href="https://realfavicongenerator.net/">Real Favicon Generator</a> where we can select an image and it will generate what we need for a PWA. 
				</p>
				<p class="paragraph">
					<strong>Splashcreen</strong>
					<br>
					Another thing that this website does is allowing us to <strong>preview and customizing the splashscreen</strong> for our App. When you click on the app, and open it you used to get a white screen for some time, this is bad UX, therefore we want to show something while the page loads. The splashcreen has the background color, name, and an icon of the web app which it gets from the manifest.json. Overall that is all we need for PWA support. 
				</p>
				<p class="paragraph">
					<strong>Requirement 3: Service Worker</strong>
					<br>
					A server worker is a script that your browser runs in the background, separate from the web app. It is used for features that don't require a web page or user interaction. It acts as a <em>programmable proxy</em> allowing us to control what happens on a request by request basis which allows our PWAs to work offline. They also help with background synchs, push notifications, and other features. We will only focus on offline, but know that you can use it for many things. 
				</p>
				<p class="paragraph">
					<strong>CRA Service Worker</strong>
					<br>
					CRA comes with a service worker. In our Index file we <code>import registerServiceWorker from './registerServiceWorker';</code> from that file, and then run it with <code>registerServiceWorker()</code> underneath our <code>ReactDOM.render(...)</code>. If we go to the file it looks a bit daunting but has some comments on it. Most browsers have service workers, however, CRA checks if there is a service worker. If a service worker is found, then it is registered <code>register()</code>, which uses the file in our CRA build folder. Once the serviceWOrker is registered, it will start the install step. Once it is activated and registered, it will be in 1 of 2 states: terminanted, or running in the background. In the Application tab of our Devtools we can see that under Manfest we have Service Workers, which will show if our page has one active at the moment.
				</p>
				<p class="paragraph">
					The flow of how a page works changes when we use service workers. When we send a request to the internet, we will go to the service worker first. This makes it act as a <strong>service proxy</strong>, it intercepts any request to the network, and checks if you need to communicate with the network or if the file is already in a cache. The service worker uses the Cache API, which comes in the browser. Files are stored here, any static files, the worker checks if what is requested is already in the box, and if it is there, the service worker will return the page without communicating with the network. If the file is not found, the request goes through and the request goes to the internet. 
				</p>
				<p class="paragraph">
					<strong>Cache API</strong>
					<br>
					If we go to our Application tab, we can see that we have <code>Cache Storage</code>. There we can see what files we have cached in our browser. Whatever we want to work offline in the app is stored by the service worker using the Cache API. On the firt page load, the files are not cached, therefore the request goes to the network and then gets stored by the service worker on the cache so that it doesn't have to fetch the files again if the app is reloaded. CRA handles this behind the scenes, before we had to install a package, add the registration to our HTML file, add a script to our build command, and then configure our service worker by telling it what files to store, similar to webpack. 
				</p>
				<a id="03" href="#00">Index</a>
				<h2 class="subtitle">Converting our App to PWA</h2>
				<p class="paragraph">
					We will go back to our CRWN clothing app. Since we used CRA, moving this to a PWA is really simple. We need to do a few tweaks for our app beyond what we have seen because we have an express server. In our index.tsx we <code>import * as serviceWorker from './serviceWorker'</code> and <code>serviceWorker.register()</code>. Since we are using an express server, whenever an application tires to load a service worker it will look for a serviceworker.js file. 
				</p>
				<p class="paragraph">
					<strong>server.ts p1</strong>
					<br>
					We start by adding a get route to <code>app.get('/service-worker.js', (req, res) => { ... })</code> Where we <code>res.send(path.resolve(__dirname, '..', 'build', 'service-worker.js'))</code> which will go one dir back, go to build/ and send the service worker file. <strong>Note:</strong> There are a few more things we will do later.
				</p>
				<p class="paragraph">
					<strong>Manifest</strong>
					<br>
					We need to modify our manifest to match our app. We cahnge short_name and name, I chose <code>CRWN-Clothing</code>. We already have a favicon.ico, which is enough to handle all of the sizes that our manifest wants. We need the PNGs for the splash screens and android icons. We copy them from resources and place them in our public/ dir. The sizes we need are 192 and 512. In the icons array we add them using the filename as the src attribute. We can also change the theme color and background color if we wanted. 
				</p>
				<p class="paragraph">
					<strong>server.ts p2</strong>
					<br>
					We need to use HTTPS, heroku gives us HTTPS but we need to redirect any HTTP request to HTTPS. To do this through Heroku, we need to put it in our application server. We do this through <code>yarn add express-sslify</code> We then need <code>yarn add @types/express-sslify</code> in our process.env.NODE_ENV === 'production' part we add <code>app.use(enforce.HTTPS({ trustProtoHeader: true }))</code>, which will enfore HTTPS when in production, but allow us to work using our localhost which doesn't use HTTPS. We need the trustProtoHeader because Heroku runs a <em>reverse-proxy</em>, if we mouseover trustProtoHeader we can see that it says: Heroku, nodejitsu and other hosters often use reverse proxies which offer SSL endpoints but then forward unencrypted HTTP traffic to the website. This makes it difficult to detect if the original request was indeed via HTTPS. Luckily, most reverse proxies set the x-forwarded-proto header flag with the original request scheme. Having done this we are done with what we needed to do in our server. 
				</p>
				<p class="paragraph">
					I had to modify the path for the service worker and name using <code>path.resolve(__dirname, '../client/build', 'serviceWorker.js')</code> which worked on heroku, but not on localhost. I then ran the test and I got better reuslts, however I don't get all traffic redirected to HTTPS in my lighthouse audit. 
				</p>
			</li>
		</ul>
	</div>

	<!-- Optional JavaScript -->
	<!-- jQuery first, then Popper.js, then Bootstrap JS -->
	<script src="https://code.jquery.com/jquery-3.4.1.slim.min.js" integrity="sha384-J6qa4849blE2+poT4WnyKhv5vZF5SrPo0iEjwBvKU7imGFAV0wwj1yYfoRSJoZ+n" crossorigin="anonymous"></script>
	<script src="https://cdn.jsdelivr.net/npm/popper.js@1.16.0/dist/umd/popper.min.js" integrity="sha384-Q6E9RHvbIyZFJoft+2mJbHaEWldlvI9IOYy5n3zV9zzTtmI3UksdQRVvoxMfooAo" crossorigin="anonymous"></script>
	<script src="https://stackpath.bootstrapcdn.com/bootstrap/4.4.1/js/bootstrap.min.js" integrity="sha384-wfSDF2E50Y2D1uUdj0O3uMBJnjuUD4Ih7YwaYd1iqfktj0Uod8GCExl3Og8ifwB6" crossorigin="anonymous"></script>
	</body>
</html>