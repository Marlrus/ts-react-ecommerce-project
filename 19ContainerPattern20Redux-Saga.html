<!doctype html>
<html lang="en">
  	<head>
		<!-- Required meta tags -->
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

		<!-- Bootstrap CSS -->
		<link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.4.1/css/bootstrap.min.css" integrity="sha384-Vkoo8x4CGsO3+Hhxv8T/Q5PaXtkKtu6ug5TOeNV6gBiFeWPGFN9MuhOf23Q9Ifjh" crossorigin="anonymous">
		<style>
			code{
				background-color: rgba(0,0,0,.075);
				font-weight: bold;
			}
			.subtitle{
				font-size: 1.3rem;
				font-weight: bold;
				margin: 0;
				padding: 5px;
				margin-top: 5px;
				background-color: rgba(0,0,0,.075);
				text-align: center;
			}
			h3{
				font-size: 2rem;
				font-weight: bold;
				margin: 0;
				padding: 5px;
				margin-top: 10px;
			}
			.paragraph{
				margin: 0.5rem 0 0.5rem;
			}
			.tab{
				margin: 0 1rem;
			}
			html{
				scroll-behavior: smooth;
			}
			</style>

		<title>19 Container Patter 20 Redux-Saga</title>
  	</head>
  	<body>
      
    <div class="container">
		<h1 class="display-3 text-center">19 Container Patter 20 Redux-Saga<hr></h1>
		<header>
			<p class="paragraph">
				Overall description.
			</p>
		</header>

		<h2 id="00" class="subtitle">Index</h2>
		<table class="table table-striped">
			<thead>
				<tr>
					<th scope="col">#</th>
					<th scope="col">Topic</th>
					<th scope="col">Description</th>
				</tr>
			</thead>
			<tbody>
				<tr>
					<th scope="row">1</th>
					<td>
						<a href="#01">topicName</a>
					</td>
					<td>
						<code>Code or description</code>
					</td>
				</tr>
			</tbody>
		</table>

		<ul class="list-group">
			<li class="list-group-item">
				<a id="01" href="#00">Index</a>
				<h2 class="subtitle">Container Pattern</h2>
				<p class="paragraph">
					At the moment we are passing two values to our ShopComponent that we only use to pass down to our children components, however we do nothing else with these props. These are polluting our ShopPage component because we are not using them for anything, which is redundant. Components shouldn't know things that don't concern them. In our case, ShopPage doesn't care weather the children components are loading or not. We will fix this through a HOC using the Container Pattern.
				</p>
				<p class="paragraph">
					<strong>collections-overview Container</strong>
					<br>
					We create a <strong>collections-overview.container.tsx</strong> to handle our HOC. Here we import connect, compose from redux, our selector, WithSpinner, CollectionsOverview, and the State type. Then we just create mapStateToProps() that passes an <code>isLoading: !selectIsCollectionsLoaded(State)</code> which is what our component is expecting as a prop. I had to return to set it to the opposite to get the proper isLoading boolean. Then we use compose to export the component, which works just as Ramda compose() does <code>const CollectionsOverviewContainer = compose( connect(mapStateToProps), WithSpinner )(CollectionsOverview)</code> which is just currying our Fns and then passing our component to them from right-to-left just as compose(). This way we are wrapping our component in WithSpinner and then connect(). Then we <code>export CollectionsOverviewContainer as React.FC</code>, we have to typecast it beacuse compose() returns unknown.
				</p>
				<p class="paragraph">
					<strong>ShopPage</strong>
					<br>
					We remove the logic for our WithSpinner from this component and just import the container. In our route we remove the render prop and replace it with <code>component={CollectionsOverviewContainer}</code> since we are calling the component directly. The Container handles the logic for the WithSpinner HOC and the loading state directly, meaning that we don't need it in our ShopPage and can keep it as clean as possible. I will attempt to do the same for the CollectionPage. I successfuly did it by myself with 1 minor mistake caused by StyledComponents, which I will replace with CSS Modules. Containers don't render anything. They just pass props down to components. After completing I did a cleanup and removed a ton of code from ShopSelector, including the complete removal of mapStateToProps(). Now our ShopPage only has what it is concernde about, triggering the data fetching, and rendering the children component without having to get props just to pass them down, this is better for separation of concerns but results in more code and files. 
				</p>
				<p class="paragraph">
					<strong>Refactoring is a Tradeoff</strong>
					<br>
					There are always things to change and improve. Refactoring adds a little bit of complexity. Not all refactoring is the same. By working in a large team it is better to refactor to keep a standard. A few files with a lot of code or more files with shorter code. Decide when to refactor, but don't end up in the loop of refactoring instead of working on features and bugs. Refactoring has diminishing returns, keep it in mind and be mindful of the time you are trading off refactoring. 
				</p>
			</li>
			<h2 class="subtitle">20 Redux-Saga</h2>
			<li class="list-group-item">
				<a id="02" href="#00">Index</a>
				<h2 class="subtitle">Intro to Sagas</h2>
				<p class="paragraph">
					This another method of handling Async Side-effects in our components that is actually more popular than thunk. In the redux flow, middleware like redux saga go between actions and reduecers and modify the data, sometimes even not passing the action to the reducer at all. Sagas are very different to Thunk. Thunk just detects actions that are passed as Fns and intercepts them and then dispatches them to the reducer once it handles the async operation. Redux-Saga works as Fns that conditionally run. The condition to decide is if a specific action is comming in to the saga middleware. Sagas are pieces of code that don't run until they are triggered by the action that they are listening for. Sagas can trigger other actions, any additional API logic, and basically anything that is considered a side-effect. Different to Thunk, Sagas go <strong>after</strong> reducers and then receive the action. From there sagas fire new actions which hit the reducers and sagas again as well. The actions that sagas are listening for are passed to the reducers but they don't react to these actions because they are intended for our sagas. 
				</p>
				<p class="paragraph">
					<strong>Generator Functions</strong>
					<br>
					This is a new-ish feature in the JS ecosystem. It is a Fn that resembles async await, in fact async await is built on top of generators. As with async/await, generators pause the execution when they see a specific key caled a yield. They use the old school function declaration syntax but use the '*' star <code>function*</code> which declares that it is a generator Fn. When we call the Fn, we get a <strong>generator object</strong>. We create <code>function* get() { console.log('a'); console.log('b') }</code> which returns undefined. We then <code>const g = gen()</code> which will also return undefined. However if we log <code>g</code> we get <code>gen {&lt;suspended&gt;}</code>. This is the generator object. What we do on it is call .next(). If we <code>g.next()</code> we run the code from our Fn and log a and b and we get an object as a return from our .next() call. This object has a value prop and a done prop. 
				</p>
				<p class="paragraph">
					<strong>yield</strong>
					<br>
					We do <code>function* gen(i) { yield i; yield i + 10 }</code>. Then we <code>const g = gen(5)</code>. Then we do our call <code>const gObj = g.next()</code> which will return undefined, however if we log our gObj we see <code>{value: 5, done: false}</code>. We get the value from the <strong>yield</strong> on the first call. Also, we get done as false becasue there is more to execture from our gen() Fn. If we do <code>const jObj = g.next()</code> we get a return of undefined but if we log the value we get <code>{ value: 15, done: false }</code>, this is because we can call .next() one more time. If we do that call we get a return obj <code>{ value: undefined, done: true }</code>. To get a value from this last call we need to specify a return, if we had <code>return 25</code> after our yield statements we would get <code>{ value: 25, done: true }</code> after our last next() call. Basically yield gives us the option to pause Fns and decide when we want to continue the execution of our Fns. 
				</p>
				<a id="03" href="#00">Index</a>
				<h2 class="subtitle">Redux-Saga</h2>
				<p class="paragraph">
					We <code>yarn add redux-saga</code> and then go to our store to add the middleware and remove thunk because we won't need it anymore. We then <code>const sagaMiddleware = createSagaMiddleware()</code> which can take an object for optional config that we are not going to use. We then <code>const middlewares: Middleware[] = [sagaMiddleware]</code> which fixes my TS err that infers that the Arr can only be of type SagaMiddleware. We create <code>shop.saga.ts</code> in the redux/shop folder, which is the standard, to keep the saga logic in their state piece. We want to move the logic from our Thunk into our saga. 
				</p>
				<p class="paragraph">
					<strong>shop.saga.ts</strong>
					<br>
					In sagas we need to import effects from the lib that allow us to do different things. We <code>import { takeEvery } from "redux-saga/effects";</code> This effect listens to every action of a specific type that we pass to it. We create <code>export function* fetchCollectionsStart() { ... }</code> That has a yield using our import <code>yield takeEvery( ShopActionTypes.FETCH_COLLECTIONS_START, fetchCollectionsAsync )</code> which will call a new gen Fn <code>export function* fetchCollectionsAsync() { yield console.log('hai') }</code> We return to our ShopPage and change all of our thunk code to just the regular action <code>fetchCollectionsStart()</code> whih will trigger the action that our saga is listening to. If we refresh we see our console log hai. We pass the action, our saga takeEvery listens to it and then fires the second argument which is fetchCollectionsAsync. 
				</p>
				<p class="paragraph">
					<strong>Sagas Theory</strong>
					<br>
					The whole purpose of the middleware is to run the sagas all <em>concurrently</em>. This means that it wants to run them all together in a non blocking manner. This means that when we trigger sagas, they can run processes that take time without blocking the functioning of our app. takeEvery() creates a <em>non blocking call</em> that doesn't stop our app from running other sagas or whatever the user wants to do. Alternatively we are also able to cnacel the tasks that are comming out of our Fn. In our case the fetchCollectionsAsync() is the saga, and the middleware is running it in the background as our app runs, if the user where to trigger the action multiple times we would be able to cancel the fetching of data if it hasn't completed as we only want the latest action to be the one executed to its fullest. With the <strong>yield</strong> inside our saga, we are yielding control to the middleware which can determine wether or not to cancel any of the previously started sagas from the other actions that came in. We have control of this because of the <em>yield</em>. 
				</p>
				<a id="04" href="#00">Index</a>
				<h2 class="subtitle">Redux-Thunk into Saga</h2>
				<p class="paragraph">
					When we used Thunk, what we did was move the async call and logic out of the Component and changed it into our actions. When we did this we had to create a new thunk action that dispatches our actions of the async request. Instead of doing this in an action, we will do it in a saga. This is why we switched the action in our Component back to the regular action. We don't need the async Fn we created to handle this anymore. We copy the logic from our Thunk and move it into our fetchCollectionsAsync() gen Fn. Here we do a try catch block and inside <code>const collectionRef = firestore.colleciton('collections')</code> which we use in <code>const snapshot = tield collectionRef.get()</code> Which we then pass to <code>const collectionsMap: ShopMap = yield call( convertCollectionsSnapshotToMap, snapshot )</code> which uses a new saga effect call(). This effect is just like calling a Fn. We could call it normally though. Then we import the next effect put(), which will replace what we usually do with dispatch(). Put dispatches out an obj with a type and a payload. We <code>yield put(fetchCollectionsSuccess(collectionsMap))</code> and one on our catch block for the error using fetchCollectionsFailure(). Every part where we use <strong>yield</strong> we are giving the saga middleware the control to intervene the event and cancel it. 
				</p>
				<p class="paragraph">
					Our app runs as expected and we can see that the action on FETCH_COLLECTIONS_SUCCESS says @@redux-saga/... which is logger letting us know where the actions are comming from. 
				</p>
				<a id="05" href="#00">Index</a>
				<h2 class="subtitle">take(), takeEvery(), takeLatest()</h2>
				<p class="paragraph">
					We start by using the base listener effects with take(). The Fn <code>take('actionType')</code> takes only one argument. take waits for the action we pass to happen, when it happens we can get the payload of the action if we wanted by setting it to a variable <code>const actionPayload = yield take('actionType')</code> It is given to us in the format of a promise that has been resolved. The rest of the code doesn't execute until the take() finishes. take() works like the generic gen Fn but with only one next() call because it only has one yield. This makes it so take() only runs once, unlike the takeEvery() we used before. takeEvery() creates a new task using the gen Fn we pass to it as a second argument. Which is why it triggers more than once. 
				</p>
				<p class="paragraph">
					<strong>takeEvery()</strong>
					<br>
					Using takeEvery(), redux-saga is firing a new task to run our gen Fn that we pass a second argument every time. This lets us use the code for the action more than one time. We could mimic this functionality with take() using a while(true){ take( ... ) ... } block. takeEvery() also creates new sagas every time it is fired, which wont happen with the while() take() setup. If we trigger it 3 times, it creates 3 actions on 3 different sagas. As we have it now, we know how to do a blocking operation, and a non blocking unlimited saga triggering saga with takeEvery(). 
				</p>
				<p class="paragraph">
					<strong>takeLatest()</strong>
					<br>
					If we have an async call that takes time to resolve, and we use it inside takeLatest('actionType', genFn), redux saga will interrupt the execution of our saga action for every action that gets triggered before the async call resolves, and will only return the last saga that was triggered by the original action. In our redux logger we can see the original action that we are triggering in the Component, because it will always get triggered. Since it is processed by our reducer first, it then moves into the middleware. However, since we have set a delay() of 3000ms, we dont see the triggering of our SAGA_ACTION if we do calls before the delay finishes and only get one SAGA_ACTION logged for the latest action that managed to finish completely. 
				</p>
				<a id="06" href="#00">Index</a>
				<h2 class="subtitle">Root Saga</h2>
				<p class="paragraph">
					We change the effect in our shop saga to takeLast(). Then we create <strong>root-saga.ts</strong> in our redux/ dir. Here we import all(), call(), and our saga fetchCollectionsStart(). Then we <code>export default function* rootSaga() { ... }</code> that uses <code>yield all([call(fetchCollectionsStart)])</code> which will call our sagas and we can then pass this rootSaga to our store.ts file. Then we go to our store.ts and import our rootSaga, and we put it in our <code>sagaMiddleware.run(rootSaga)</code> which means we now handle all the sagas in a separate file, separating concerns. all() takes an array of sagas and executes them in parallel. Like await Promise.all(). Now we can run all the sagas we want in parallel. 
				</p>
				<a id="06" href="#00">Index</a>
				<h2 class="subtitle">Google Sign In to Sagas</h2>
				<p class="paragraph">
					We want to change the signin to a promise oriented way. We have it in an observable way using the firebase auth library. We create 6 new userActionTypes 3 for google and 3 for email with start, success, and failure. We then create 6 actions for each case. On the start we just send the type and no payload, as it will just signify the start of the process. Then we have a success that will have the user as a payload. And then a failure action for the error message. I did all the TS typing here. We then add a payload to emailSignInStart() because it takes emailAndPassword. We will be passing them as an object. 
				</p>
				<p class="paragraph">
					<strong>User Reducer</strong>
					<br>
					Here we change the reducer with a new format. We stack to cases on top of one another <code>case userActionTypes.GOOGLE_SIGN_IN_SUCCESS: case userActionTypes.EMAIL_SIGN_IN_SUCCESS: </code> which will both have the same return, <code>return { ...state, currentUser: action.payload, error:null }</code>. Then we do the same for our failure actions. Here we will <code>return { ...state, error: action.payload }</code> which we will clear if we succeed in our login. We then go to ur App Component and comment out all the logic and imports related to auth. 
				</p>
				<p class="paragraph">
					<strong>User Sagas</strong>
					<br>
					We create our <strong>user.sagas.ts</strong> file. We then import takeLatest and put from redux-saga/effects and import the action types. We create our 2 generator Fns <code>export function* onGoogleSignInStart() { ... }</code> and <code>export function* signInWithGoogle() { ... }</code> but we need to change some things first. In our firebase.utils we change all provider vars to <code>googleProvider</code>. And we will <code>export const googleProvider</code>. We then <code>import { googleProvider, auth, createUserProfileDocument } from "../../firebase/firebase.utils";</code> in our sagas. 
				</p>
				<p class="paragraph">
					<strong>Sign in Logic</strong>
					<br>
					We make a try catch block in our signInWithGoogle() generator Fn. Here we start with <code>const userRef = yield auth.signInWithPopup(googleProvider)</code>, which will store the returned value from our call in userRef becasue of yield. We will then log userRef. After this we create a new saga <code>export function* userSagas() { yield all([call(onGoogleSignInStart)]) }</code> which we will send to the root saga and add it to the call() statement there. 
				</p>
				<p class="paragraph">
					<strong>SignIn Component</strong>
					<br>
					In our Component we import connect, ConnectedProps, UserActions type, and googleSignInStart action. We mapDispatchToProps() where we send our action, and we do our normal Ts typing. Then we set the generic in our React.Component <code>SignInProps, SignInState</code> where we also need to type the constructor <code>props: SignInProps</code>. Then in our render() we <code>const { googleSignInStart } = this.props</code> and we put it on our CustomButton <code>onClick={googleSignInStart}</code> now if we press the button we trigger the popup and if we proceed we get the user auth object. 
				</p>
				<p class="paragraph">
					<strong>user.sagas</strong>
					<br>
					We need to destructure the user from this auth object, so in our saga signInWithGoogle() we <code>const { user } = yield auth.signInWithPopup(googleProvider)</code> which will give us what we want. Then we run that through our createUserProfileDocument() Fn that converts our Google Firebase response into a userRef object. However, we need to get the snapshot from that userRef value in order to use it so we <code>const userSnapshot = yield userRef.get()</code> Then we import the action we want to fire if this all succeeds with <code>yield put(googleSignInSuccess({id: userSnapshot.id, ...userSnapshot.data()})</code> which will use our action and put this back into the redux flow. Then in the catch { ... } we tield the put of our err <code>yield put(googleSignInFailure(err.message)</code> Now our app works as we had it but uses sagas instead. 
				</p>
				<a id="07" href="#00">Index</a>
				<h2 class="subtitle">Email Sign In to Sagas</h2>
				<p class="paragraph">
					We don't need to set state in our component anymore because Redux will take over state from now on via sagas. We don't need utils from firebase so we remove the import as well. We then move into <strong>user.sagas.ts</strong> and create our logic. We start with our <code>export function* onEmailSignInStart() { ... }</code> which will listen for the event EMAIL_SIGN_IN_START and trigger our next gen Fn signInWithEmail. We create <code>export function* signInWithEmail({ payload: { email, password } }: emailSignInStartAction ) { ... }</code> which will destructure what we need from the payload of the action. Then we do a try catch block and run our logic. It is the same as the one in our signInWithGoogle() except that we get the user using another method <code>const { user } = yield auth.signInWithEmailAndPassword(email, password)</code> which will get the user using our firebase auth method. Then we do the same thing with userRef and userRef.get(). Then we just trigger our Redux action with <code>yield put( emailSignInSuccess({ id: userSnapshot.id, ...userSnapshot.data() })</code> which will send things back to the redux flow.
				</p>
				<p class="paragraph">
					<strong>Refactor</strong>
					<br>
					Now we run our app and test our email sign in and it works perfectly. We can refactor some of our code because we have a lot of very similar code. We remove two actions and just do <code>signInSuccess</code> and <code>signInFailure</code>, I do the TS typing accordingly. We then do that adjustment in our actions, just getting signInSuccess() and signInFailure(). We also remove the setCurrentUser() action and typing because we are not using it anymore. Now we move into our App.tsx and remove setCurrentUser and mapDispatchToProps(). In our user.sagas.ts we replace our calls with the new success and failure actions. Now in our user.reducer.ts we remove our stacked cases and use our new actions. 
				</p>
				<p class="paragraph">
					Now we have the same functionality after our refactor. However we cannot sign out anymore and we don't have persistance for our user either. Back in our sagas, we have a lot of repeated code in our try catch blocks, so we <code>function* getSnapshotFromUserAuth(userAuth: any) { ... }</code> that will handle our logic in both calls. Inside we copy the code from signInWithGoogle() after we get the user object. And then we call thsi method. We do the same in signInWithEmail() and we have refactored our code. <strong>Note:</strong> I had an err where I forgot to <em>yield</em> inside the saga and it was not being passed anywhere. 
				</p>
				<a id="08" href="#00">Index</a>
				<h2 class="subtitle">Reviewing our Sagas</h2>
				<p class="paragraph">
					We broke up all of our async related fetch actions into 3 actions <em>start, success, failure</em>. Our components fire the first action <em>start</em> which is what redux-saga is listening to and triggers our sagas. Our sagas fetch these actions using takeEvery(), takeLatest(), or take(). After our sagas execute, they launch our actions back into the flow, however, since our saga middleware is not listening for these actions, it is not triggered. We send/dispatch these actions back into the flow using the redux-saga method put(). The only difference between the shop sagas and user sagas is that we are handling two streams for our user, one for starting our auth with google, and one for starting our auth using email. We were able to do a refactor because the methods we use from the auth library return the same user object, and the same error. 
				</p>
				<a id="09" href="#00">Index</a>
				<h2 class="subtitle">Recreating persistence</h2>
				<p class="paragraph">
					We will use a saga to check for our user in App.tsx. We create a new action <code>export const checkUserSession() { ... }</code> that will just have a type to trigger our saga. We do the typing and add the new action type to our types. We import this action into App and then pass it to mapDispatchToProps(). Then we destructure it inside of componentDidMount() and call it <code>checkUserSession()</code>. Now when we reload our app we have the action firing, which is what will trigger our sagas. We set up our saga to listen for this action and create a new gen Fn <code>export function* isUserAuthenticated() { ... }</code>
				</p>
				<p class="paragraph">
					There is no promise based way to do this check. So we will use the method we already had to create a subscription, but we will unsubscribe as soon as we get our auth object. We create <code>export const getCurrentUser = () => { ... }</code> that will <code>return new Promise((resolve, reject) => { ... })</code> that will do the same unsubscribe logic we had <code>const unsubscribe = auth.onAuthStateChanged((userAuth) => { unsubscribe(), resolve(userAuth) }, reject )</code> which will get our userAuth object that we will return from our resolved promise, and unsubscribe() immediately. We then send the resolve, and also return reject which will throw the err object. 
				</p>
				<p class="paragraph">
					<strong>user.sagas.ts</strong>
					<br>
					We work on our Fn <code>export function* isUserAuthenticated() { ... }</code> where we create a try catch block. In our catch we <code>yield put(signInFailure(err.message))</code> which is the code we refactored. And then we need to get the user object to pass to our refactored method getSnapshotFromUserAuth() <code>const userAuth = yield getCurrentUser()</code> and if we don't have an object here <code>if(!userAuth) return</code> we will return and cancel the rest of the call. If we do get a response we <code>yield getSnapshotFromUserAuth(userAuth)</code> which will log us in and create our persistence. Now if we log in and then refresh we will see these actions fire and that our presistence is there. We also need to add this saga to the userSagas <code>yield all([... call(onCheckUserSerssion)])</code> which will make the middleware detect this.
				</p>
				<a id="10" href="#00">Index</a>
				<h2 class="subtitle">Sign Out with Sagas</h2>
				<p class="paragraph">
					We start by creating the new 3 actions for sign out: <em>start, success, failure</em>. We create them, start and success don't have a payload, just the action, and error has the error message as the payload. In our <strong>user.reducer.ts</strong> we stack the case SIGN_OUT_FAILURE on top of sign in failure. And then we process a new case <code>case userActionTypes.SIGN_OUT_SUCCESS: return { ...state, currentUser: null, error: null }</code> which will handle our sign out state changes. 
				</p>
				<p class="paragraph">
					<strong>Header Component</strong>
					<br>
					We dont need auth so we remove it form the imports, but we import the action <code>signOutStart</code>, Dispatch, and UserActions type. Then we send it through mapDispatchToProps() and destructure it in our props. Then in our OptionLink component we set <code>onClick={signOutStart}</code> which will trigger our action and make redux saga handle the logic. 
				</p>
				<p class="paragraph">
					<strong>user.sagas.ts</strong>
					<br>
					We create our sign out logic <code>export function* onSignOutStart() { ... }</code> which will be the listener <code>yield takeLatest(userActionTypes.SIGN_OUT_START, signOut)</code> and we create <code>function* signOut() { ... }</code> which will be the one handling the logic and triggering our actions. We import the success and failure actions and then create our try catch block. In our catch we <code>yield put(signOutFailure(err.message))</code> and in our try we <code>yield auth.signOut(); yield put(signOutSuccess())</code> which will trigger our success. Now our sign out is working in our app using sagas and we have effectively separated all that is our logic from our component. 
				</p>
				<a id="11" href="#00">Index</a>
				<h2 class="subtitle">Clear Cart Saga</h2>
				<p class="paragraph">
					We will leverage our saga to trigger another event upon signing out, the clearing of our cart. There are two ways to do this. Inside of our cart reducer, we could listen for our sign out success action and have it clear the cart when it is triggered. This can happen because all of our reducers recieve every action that is dispatched in our application, even if it is not part of their jurisdiction. However, we might want to have more cases where the user clears the cart, such as a button in the cart, or when the user completes their purchase. Therefore we will handle all of this logic in our redux/cart/ dir. 
				</p>
				<p class="paragraph">
					We create a new action clearCart() that will only have a type that we will use to trigger our saga. Then we need to create the sagas file. We <code>import { all, call, takeLatest, put } from "redux-saga/effects";</code> We then create our root cart saga <code>export function* cartSagas() { ... }</code> which will use yield all(). Then we create our listener <code>export function* onSignOutSuccess() { ... }</code> which will actually listen to UserActionTypes <code>yield takeLatest( UserActionTypes.SIGN_OUT_SUCCESS, clearCartOnSignOut)</code> which will be our saga <code>export function* clearCartOnSignOut() { yield put(clearCart()) }</code> which will just trigger our action using put(). Then we send them to the root saga with <code>yield all([call(onSignOutSuccess)])</code>. Then we move into the <strong>root-saga.ts</strong> and add it to our rootSaga() export yield all() statement so that our middleware gets it.
				</p>
				<p class="paragraph">
					<strong>cart reducer</strong>
					<br>
					Now we have our action triggering when we click sign out, but we have nothing happening yet. We update our reducer to listen for our clearCart() action and <code>return{ ...state, cartItems: [] }</code> which replaces our item array with an empty array. Now testing the app we have everything firing, and our cart gets wiped on logout. The great thing about the redux, redux-saga combo, is that we can separate our logic from our components, creating a somewhat back-end front-end separation inside our own app. 
				</p>
				<p class="paragraph">
					as our final refactor, we use the same patter of creating a root saga for each of our redux state pieces and create <code>shopSagas</code> which we use in our root-saga.ts file.
				</p>
				<a id="12" href="#00">Index</a>
				<h2 class="subtitle">Sign Up Saga By myself</h2>
				<p class="paragraph">
					I successfuly refactored the functionality on one try, with 1 minor mistake, forgetting to put the saga listener in the user root saga. After watching the video I forgot to add the sign up failure to the reducer, and I can refactor it to separate the concerns better. The proces was started by creating 3 actions for sign up: start, success, failure. We created the actions for them, and we created a saga listener for sign up start. That listener triggers the saga that handles the logic. The action would have the payload with all the data we need to create the user and to sign in <code>payload: { email, password, displayName }</code> inside we place the logic from our component to get <code>const { user }</code> which we need for our success action.
				</p>
				<p class="paragraph">
					we <code>yield put(signUpSuccess({ user, additionalData: { displayName })</code> after we create our use with <code>const { user } = yield auth.createUserWithEmailAndPassword( email, password )</code> that we got from the action payload. After this I had set another put() to trigger signInWithEmail, but to keep the format the same, we will create new sagas that listen for our signUpSuccess action and sign us in. I created these sagas and the gen Fn that would trigger getSnapshotFromUserAuth() which will sign the user in. Here I did <code>export function* signInAfterSignUp({ payload: { user, additionalData }: signUpSuccessAction) { ... }</code> that runs our logic <code>yield getSnapshotFromUserAuth(user, additionalData)</code>. If we go to firebase utils we can see that we can pass that param to the Fn, however we don't have it set up. I added it to <code>function* getSnapshotFromUserAuth( userAuth: any, additionalData? any ) { ... }</code> which now calls <code>createUserProfileDocument(userAuth, additionalData )</code> which is handled in our firebase utils.
				</p>
				<p class="paragraph">
					Now when the user signs up the action triggers a saga that will trigger the sign in logic using the payload from the action that will create a new user if there is no user in our firestore and sign us up. The way I had it before had less code, but it didn't follow the flow we are creating, an action that triggers the sagas, and we can now re-use our code as well. 
				</p>
			</li>
		</ul>
	</div>

	<!-- Optional JavaScript -->
	<!-- jQuery first, then Popper.js, then Bootstrap JS -->
	<script src="https://code.jquery.com/jquery-3.4.1.slim.min.js" integrity="sha384-J6qa4849blE2+poT4WnyKhv5vZF5SrPo0iEjwBvKU7imGFAV0wwj1yYfoRSJoZ+n" crossorigin="anonymous"></script>
	<script src="https://cdn.jsdelivr.net/npm/popper.js@1.16.0/dist/umd/popper.min.js" integrity="sha384-Q6E9RHvbIyZFJoft+2mJbHaEWldlvI9IOYy5n3zV9zzTtmI3UksdQRVvoxMfooAo" crossorigin="anonymous"></script>
	<script src="https://stackpath.bootstrapcdn.com/bootstrap/4.4.1/js/bootstrap.min.js" integrity="sha384-wfSDF2E50Y2D1uUdj0O3uMBJnjuUD4Ih7YwaYd1iqfktj0Uod8GCExl3Og8ifwB6" crossorigin="anonymous"></script>
	</body>
</html>