<!doctype html>
<html lang="en">
  	<head>
		<!-- Required meta tags -->
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

		<!-- Bootstrap CSS -->
		<link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.4.1/css/bootstrap.min.css" integrity="sha384-Vkoo8x4CGsO3+Hhxv8T/Q5PaXtkKtu6ug5TOeNV6gBiFeWPGFN9MuhOf23Q9Ifjh" crossorigin="anonymous">
		<style>
			code{
				background-color: rgba(0,0,0,.075);
				font-weight: bold;
			}
			.subtitle{
				font-size: 1.3rem;
				font-weight: bold;
				margin: 0;
				padding: 5px;
				margin-top: 5px;
				background-color: rgba(0,0,0,.075);
				text-align: center;
			}
			h3{
				font-size: 2rem;
				font-weight: bold;
				margin: 0;
				padding: 5px;
				margin-top: 10px;
			}
			.paragraph{
				margin: 0.5rem 0 0.5rem;
			}
			.tab{
				margin: 0 1rem;
			}
			html{
				scroll-behavior: smooth;
			}
			</style>

		<title>19 Container Patter 20 Redux-Saga</title>
  	</head>
  	<body>
      
    <div class="container">
		<h1 class="display-3 text-center">19 Container Patter 20 Redux-Saga<hr></h1>
		<header>
			<p class="paragraph">
				Overall description.
			</p>
		</header>

		<h2 id="00" class="subtitle">Index</h2>
		<table class="table table-striped">
			<thead>
				<tr>
					<th scope="col">#</th>
					<th scope="col">Topic</th>
					<th scope="col">Description</th>
				</tr>
			</thead>
			<tbody>
				<tr>
					<th scope="row">1</th>
					<td>
						<a href="#01">topicName</a>
					</td>
					<td>
						<code>Code or description</code>
					</td>
				</tr>
			</tbody>
		</table>

		<ul class="list-group">
			<li class="list-group-item">
				<a id="01" href="#00">Index</a>
				<h2 class="subtitle">Container Pattern</h2>
				<p class="paragraph">
					At the moment we are passing two values to our ShopComponent that we only use to pass down to our children components, however we do nothing else with these props. These are polluting our ShopPage component because we are not using them for anything, which is redundant. Components shouldn't know things that don't concern them. In our case, ShopPage doesn't care weather the children components are loading or not. We will fix this through a HOC using the Container Pattern.
				</p>
				<p class="paragraph">
					<strong>collections-overview Container</strong>
					<br>
					We create a <strong>collections-overview.container.tsx</strong> to handle our HOC. Here we import connect, compose from redux, our selector, WithSpinner, CollectionsOverview, and the State type. Then we just create mapStateToProps() that passes an <code>isLoading: !selectIsCollectionsLoaded(State)</code> which is what our component is expecting as a prop. I had to return to set it to the opposite to get the proper isLoading boolean. Then we use compose to export the component, which works just as Ramda compose() does <code>const CollectionsOverviewContainer = compose( connect(mapStateToProps), WithSpinner )(CollectionsOverview)</code> which is just currying our Fns and then passing our component to them from right-to-left just as compose(). This way we are wrapping our component in WithSpinner and then connect(). Then we <code>export CollectionsOverviewContainer as React.FC</code>, we have to typecast it beacuse compose() returns unknown.
				</p>
				<p class="paragraph">
					<strong>ShopPage</strong>
					<br>
					We remove the logic for our WithSpinner from this component and just import the container. In our route we remove the render prop and replace it with <code>component={CollectionsOverviewContainer}</code> since we are calling the component directly. The Container handles the logic for the WithSpinner HOC and the loading state directly, meaning that we don't need it in our ShopPage and can keep it as clean as possible. I will attempt to do the same for the CollectionPage. I successfuly did it by myself with 1 minor mistake caused by StyledComponents, which I will replace with CSS Modules. Containers don't render anything. They just pass props down to components. After completing I did a cleanup and removed a ton of code from ShopSelector, including the complete removal of mapStateToProps(). Now our ShopPage only has what it is concernde about, triggering the data fetching, and rendering the children component without having to get props just to pass them down, this is better for separation of concerns but results in more code and files. 
				</p>
				<p class="paragraph">
					<strong>Refactoring is a Tradeoff</strong>
					<br>
					There are always things to change and improve. Refactoring adds a little bit of complexity. Not all refactoring is the same. By working in a large team it is better to refactor to keep a standard. A few files with a lot of code or more files with shorter code. Decide when to refactor, but don't end up in the loop of refactoring instead of working on features and bugs. Refactoring has diminishing returns, keep it in mind and be mindful of the time you are trading off refactoring. 
				</p>
			</li>
			<h2 class="subtitle">20 Redux-Saga</h2>
			<li class="list-group-item">
				<a id="02" href="#00">Index</a>
				<h2 class="subtitle">Intro to Sagas</h2>
				<p class="paragraph">
					This another method of handling Async Side-effects in our components that is actually more popular than thunk. In the redux flow, middleware like redux saga go between actions and reduecers and modify the data, sometimes even not passing the action to the reducer at all. Sagas are very different to Thunk. Thunk just detects actions that are passed as Fns and intercepts them and then dispatches them to the reducer once it handles the async operation. Redux-Saga works as Fns that conditionally run. The condition to decide is if a specific action is comming in to the saga middleware. Sagas are pieces of code that don't run until they are triggered by the action that they are listening for. Sagas can trigger other actions, any additional API logic, and basically anything that is considered a side-effect. Different to Thunk, Sagas go <strong>after</strong> reducers and then receive the action. From there sagas fire new actions which hit the reducers and sagas again as well. The actions that sagas are listening for are passed to the reducers but they don't react to these actions because they are intended for our sagas. 
				</p>
				<p class="paragraph">
					<strong>Generator Functions</strong>
					<br>
					This is a new-ish feature in the JS ecosystem. It is a Fn that resembles async await, in fact async await is built on top of generators. As with async/await, generators pause the execution when they see a specific key caled a yield. They use the old school function declaration syntax but use the '*' star <code>function*</code> which declares that it is a generator Fn. When we call the Fn, we get a <strong>generator object</strong>. We create <code>function* get() { console.log('a'); console.log('b') }</code> which returns undefined. We then <code>const g = gen()</code> which will also return undefined. However if we log <code>g</code> we get <code>gen {&lt;suspended&gt;}</code>. This is the generator object. What we do on it is call .next(). If we <code>g.next()</code> we run the code from our Fn and log a and b and we get an object as a return from our .next() call. This object has a value prop and a done prop. 
				</p>
				<p class="paragraph">
					<strong>yield</strong>
					<br>
					We do <code>function* gen(i) { yield i; yield i + 10 }</code>. Then we <code>const g = gen(5)</code>. Then we do our call <code>const gObj = g.next()</code> which will return undefined, however if we log our gObj we see <code>{value: 5, done: false}</code>. We get the value from the <strong>yield</strong> on the first call. Also, we get done as false becasue there is more to execture from our gen() Fn. If we do <code>const jObj = g.next()</code> we get a return of undefined but if we log the value we get <code>{ value: 15, done: false }</code>, this is because we can call .next() one more time. If we do that call we get a return obj <code>{ value: undefined, done: true }</code>. To get a value from this last call we need to specify a return, if we had <code>return 25</code> after our yield statements we would get <code>{ value: 25, done: true }</code> after our last next() call. Basically yield gives us the option to pause Fns and decide when we want to continue the execution of our Fns. 
				</p>
				<a id="03" href="#00">Index</a>
				<h2 class="subtitle">Redux-Saga</h2>
				<p class="paragraph">
					We <code>yarn add redux-saga</code> and then go to our store to add the middleware and remove thunk because we won't need it anymore. We then <code>const sagaMiddleware = createSagaMiddleware()</code> which can take an object for optional config that we are not going to use. We then <code>const middlewares: Middleware[] = [sagaMiddleware]</code> which fixes my TS err that infers that the Arr can only be of type SagaMiddleware. We create <code>shop.saga.ts</code> in the redux/shop folder, which is the standard, to keep the saga logic in their state piece. We want to move the logic from our Thunk into our saga. 
				</p>
				<p class="paragraph">
					<strong>shop.saga.ts</strong>
					<br>
					In sagas we need to import effects from the lib that allow us to do different things. We <code>import { takeEvery } from "redux-saga/effects";</code> This effect listens to every action of a specific type that we pass to it. We create <code>export function* fetchCollectionsStart() { ... }</code> That has a yield using our import <code>yield takeEvery( ShopActionTypes.FETCH_COLLECTIONS_START, fetchCollectionsAsync )</code> which will call a new gen Fn <code>export function* fetchCollectionsAsync() { yield console.log('hai') }</code> We return to our ShopPage and change all of our thunk code to just the regular action <code>fetchCollectionsStart()</code> whih will trigger the action that our saga is listening to. If we refresh we see our console log hai. We pass the action, our saga takeEvery listens to it and then fires the second argument which is fetchCollectionsAsync. 
				</p>
				<p class="paragraph">
					<strong>Sagas Theory</strong>
					<br>
					The whole purpose of the middleware is to run the sagas all <em>concurrently</em>. This means that it wants to run them all together in a non blocking manner. This means that when we trigger sagas, they can run processes that take time without blocking the functioning of our app. takeEvery() creates a <em>non blocking call</em> that doesn't stop our app from running other sagas or whatever the user wants to do. Alternatively we are also able to cnacel the tasks that are comming out of our Fn. In our case the fetchCollectionsAsync() is the saga, and the middleware is running it in the background as our app runs, if the user where to trigger the action multiple times we would be able to cancel the fetching of data if it hasn't completed as we only want the latest action to be the one executed to its fullest. With the <strong>yield</strong> inside our saga, we are yielding control to the middleware which can determine wether or not to cancel any of the previously started sagas from the other actions that came in. We have control of this because of the <em>yield</em>. 
				</p>
				<a id="04" href="#00">Index</a>
				<h2 class="subtitle">Redux-Thunk into Saga</h2>
				<p class="paragraph">
					When we used Thunk, what we did was move the async call and logic out of the Component and changed it into our actions. When we did this we had to create a new thunk action that dispatches our actions of the async request. Instead of doing this in an action, we will do it in a saga. This is why we switched the action in our Component back to the regular action. We don't need the async Fn we created to handle this anymore. We copy the logic from our Thunk and move it into our fetchCollectionsAsync() gen Fn. Here we do a try catch block and inside <code>const collectionRef = firestore.colleciton('collections')</code> which we use in <code>const snapshot = tield collectionRef.get()</code> Which we then pass to <code>const collectionsMap: ShopMap = yield call( convertCollectionsSnapshotToMap, snapshot )</code> which uses a new saga effect call(). This effect is just like calling a Fn. We could call it normally though. Then we import the next effect put(), which will replace what we usually do with dispatch(). Put dispatches out an obj with a type and a payload. We <code>yield put(fetchCollectionsSuccess(collectionsMap))</code> and one on our catch block for the error using fetchCollectionsFailure(). Every part where we use <strong>yield</strong> we are giving the saga middleware the control to intervene the event and cancel it. 
				</p>
				<p class="paragraph">
					Our app runs as expected and we can see that the action on FETCH_COLLECTIONS_SUCCESS says @@redux-saga/... which is logger letting us know where the actions are comming from. 
				</p>
				<a id="05" href="#00">Index</a>
				<h2 class="subtitle">take(), takeEvery(), takeLatest()</h2>
				<p class="paragraph">
					We start by using the base listener effects with take(). The Fn <code>take('actionType')</code> takes only one argument. take waits for the action we pass to happen, when it happens we can get the payload of the action if we wanted by setting it to a variable <code>const actionPayload = yield take('actionType')</code> It is given to us in the format of a promise that has been resolved. The rest of the code doesn't execute until the take() finishes. take() works like the generic gen Fn but with only one next() call because it only has one yield. This makes it so take() only runs once, unlike the takeEvery() we used before. takeEvery() creates a new task using the gen Fn we pass to it as a second argument. Which is why it triggers more than once. 
				</p>
				<p class="paragraph">
					<strong>takeEvery()</strong>
					<br>
					Using takeEvery(), redux-saga is firing a new task to run our gen Fn that we pass a second argument every time. This lets us use the code for the action more than one time. We could mimic this functionality with take() using a while(true){ take( ... ) ... } block. takeEvery() also creates new sagas every time it is fired, which wont happen with the while() take() setup. If we trigger it 3 times, it creates 3 actions on 3 different sagas. As we have it now, we know how to do a blocking operation, and a non blocking unlimited saga triggering saga with takeEvery(). 
				</p>
				<p class="paragraph">
					<strong>takeLatest()</strong>
					<br>
					If we have an async call that takes time to resolve, and we use it inside takeLatest('actionType', genFn), redux saga will interrupt the execution of our saga action for every action that gets triggered before the async call resolves, and will only return the last saga that was triggered by the original action. In our redux logger we can see the original action that we are triggering in the Component, because it will always get triggered. Since it is processed by our reducer first, it then moves into the middleware. However, since we have set a delay() of 3000ms, we dont see the triggering of our SAGA_ACTION if we do calls before the delay finishes and only get one SAGA_ACTION logged for the latest action that managed to finish completely. 
				</p>
				<a id="06" href="#00">Index</a>
				<h2 class="subtitle">Root Saga</h2>
				<p class="paragraph">
					We change the effect in our shop saga to takeLast(). Then we create <strong>root-saga.ts</strong> in our redux/ dir. Here we import all(), call(), and our saga fetchCollectionsStart(). Then we <code>export default function* rootSaga() { ... }</code> that uses <code>yield all([call(fetchCollectionsStart)])</code> which will call our sagas and we can then pass this rootSaga to our store.ts file. Then we go to our store.ts and import our rootSaga, and we put it in our <code>sagaMiddleware.run(rootSaga)</code> which means we now handle all the sagas in a separate file, separating concerns. all() takes an array of sagas and executes them in parallel. Like await Promise.all(). Now we can run all the sagas we want in parallel. 
				</p>
				<a id="06" href="#00">Index</a>
				<h2 class="subtitle">Google Sign In to Sagas</h2>
				<p class="paragraph">
					We want to change the signin to a promise oriented way. We have it in an observable way using the firebase auth library. We create 6 new userActionTypes 3 for google and 3 for email with start, success, and failure. We then create 6 actions for each case. On the start we just send the type and no payload, as it will just signify the start of the process. Then we have a success that will have the user as a payload. And then a failure action for the error message. I did all the TS typing here. We then add a payload to emailSignInStart() because it takes emailAndPassword. We will be passing them as an object. 
				</p>
				<p class="paragraph">
					<strong>User Reducer</strong>
					<br>
					Here we change the reducer with a new format. We stack to cases on top of one another <code>case userActionTypes.GOOGLE_SIGN_IN_SUCCESS: case userActionTypes.EMAIL_SIGN_IN_SUCCESS: </code> which will both have the same return, <code>return { ...state, currentUser: action.payload, error:null }</code>. Then we do the same for our failure actions. Here we will <code>return { ...state, error: action.payload }</code> which we will clear if we succeed in our login. We then go to ur App Component and comment out all the logic and imports related to auth. 
				</p>
				<p class="paragraph">
					<strong>User Sagas</strong>
					<br>
					We create our <strong>user.sagas.ts</strong> file. We then import takeLatest and put from redux-saga/effects and import the action types. We create our 2 generator Fns <code>export function* onGoogleSignInStart() { ... }</code> and <code>export function* signInWithGoogle() { ... }</code> but we need to change some things first. In our firebase.utils we change all provider vars to <code>googleProvider</code>. And we will <code>export const googleProvider</code>. We then <code>import { googleProvider, auth, createUserProfileDocument } from "../../firebase/firebase.utils";</code> in our sagas. 
				</p>
				<p class="paragraph">
					<strong>Sign in Logic</strong>
					<br>
					We make a try catch block in our signInWithGoogle() generator Fn. Here we start with <code>const userRef = yield auth.signInWithPopup(googleProvider)</code>, which will store the returned value from our call in userRef becasue of yield. We will then log userRef. After this we create a new saga <code>export function* userSagas() { yield all([call(onGoogleSignInStart)]) }</code> which we will send to the root saga and add it to the call() statement there. 
				</p>
				<p class="paragraph">
					<strong>SignIn Component</strong>
					<br>
					In our Component we import connect, ConnectedProps, UserActions type, and googleSignInStart action. We mapDispatchToProps() where we send our action, and we do our normal Ts typing. Then we set the generic in our React.Component <code>SignInProps, SignInState</code> where we also need to type the constructor <code>props: SignInProps</code>. Then in our render() we <code>const { googleSignInStart } = this.props</code> and we put it on our CustomButton <code>onClick={googleSignInStart}</code> now if we press the button we trigger the popup and if we proceed we get the user auth object. 
				</p>
				<p class="paragraph">
					<strong>user.sagas</strong>
					<br>
					We need to destructure the user from this auth object, so in our saga signInWithGoogle() we <code>const { user } = yield auth.signInWithPopup(googleProvider)</code> which will give us what we want. Then we run that through our createUserProfileDocument() Fn that converts our Google Firebase response into a userRef object. However, we need to get the snapshot from that userRef value in order to use it so we <code>const userSnapshot = yield userRef.get()</code> Then we import the action we want to fire if this all succeeds with <code>yield put(googleSignInSuccess({id: userSnapshot.id, ...userSnapshot.data()})</code> which will use our action and put this back into the redux flow. Then in the catch { ... } we tield the put of our err <code>yield put(googleSignInFailure(err.message)</code> Now our app works as we had it but uses sagas instead. 
				</p>
				<a id="07" href="#00">Index</a>
				<h2 class="subtitle">Email Sign In to Sagas</h2>
				<p class="paragraph">
					We don't need to set state in our component anymore because Redux will take over state from now on via sagas. We don't need utils from firebase so we remove the import as well. We then move into <strong>user.sagas.ts</strong> and create our logic. We start with our <code>export function* onEmailSignInStart() { ... }</code> which will listen for the event EMAIL_SIGN_IN_START and trigger our next gen Fn signInWithEmail. We create <code>export function* signInWithEmail({ payload: { email, password } }: emailSignInStartAction ) { ... }</code> which will destructure what we need from the payload of the action. Then we do a try catch block and run our logic. It is the same as the one in our signInWithGoogle() except that we get the user using another method <code>const { user } = yield auth.signInWithEmailAndPassword(email, password)</code> which will get the user using our firebase auth method. Then we do the same thing with userRef and userRef.get(). Then we just trigger our Redux action with <code>yield put( emailSignInSuccess({ id: userSnapshot.id, ...userSnapshot.data() })</code> which will send things back to the redux flow.
				</p>
				<p class="paragraph">
					<strong>Refactor</strong>
					<br>
					Now we run our app and test our email sign in and it works perfectly. We can refactor some of our code because we have a lot of very similar code. We remove two actions and just do <code>signInSuccess</code> and <code>signInFailure</code>, I do the TS typing accordingly. We then do that adjustment in our actions, just getting signInSuccess() and signInFailure(). We also remove the setCurrentUser() action and typing because we are not using it anymore. Now we move into our App.tsx and remove setCurrentUser and mapDispatchToProps(). In our user.sagas.ts we replace our calls with the new success and failure actions. Now in our user.reducer.ts we remove our stacked cases and use our new actions. 
				</p>
				<p class="paragraph">
					Now we have the same functionality after our refactor. However we cannot sign out anymore and we don't have persistance for our user either. Back in our sagas, we have a lot of repeated code in our try catch blocks, so we <code>function* getSnapshotFromUserAuth(userAuth: any) { ... }</code> that will handle our logic in both calls. Inside we copy the code from signInWithGoogle() after we get the user object. And then we call thsi method. We do the same in signInWithEmail() and we have refactored our code. <strong>Note:</strong> I had an err where I forgot to <em>yield</em> inside the saga and it was not being passed anywhere. 
				</p>
			</li>
		</ul>
	</div>

	<!-- Optional JavaScript -->
	<!-- jQuery first, then Popper.js, then Bootstrap JS -->
	<script src="https://code.jquery.com/jquery-3.4.1.slim.min.js" integrity="sha384-J6qa4849blE2+poT4WnyKhv5vZF5SrPo0iEjwBvKU7imGFAV0wwj1yYfoRSJoZ+n" crossorigin="anonymous"></script>
	<script src="https://cdn.jsdelivr.net/npm/popper.js@1.16.0/dist/umd/popper.min.js" integrity="sha384-Q6E9RHvbIyZFJoft+2mJbHaEWldlvI9IOYy5n3zV9zzTtmI3UksdQRVvoxMfooAo" crossorigin="anonymous"></script>
	<script src="https://stackpath.bootstrapcdn.com/bootstrap/4.4.1/js/bootstrap.min.js" integrity="sha384-wfSDF2E50Y2D1uUdj0O3uMBJnjuUD4Ih7YwaYd1iqfktj0Uod8GCExl3Og8ifwB6" crossorigin="anonymous"></script>
	</body>
</html>