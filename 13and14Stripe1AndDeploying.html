<!DOCTYPE html>
<html lang="en">
   <head>
      <!-- Required meta tags -->
      <meta charset="utf-8" />
      <meta
         name="viewport"
         content="width=device-width, initial-scale=1, shrink-to-fit=no"
      />

      <!-- Bootstrap CSS -->
      <link
         rel="stylesheet"
         href="https://stackpath.bootstrapcdn.com/bootstrap/4.4.1/css/bootstrap.min.css"
         integrity="sha384-Vkoo8x4CGsO3+Hhxv8T/Q5PaXtkKtu6ug5TOeNV6gBiFeWPGFN9MuhOf23Q9Ifjh"
         crossorigin="anonymous"
      />
      <style>
         code {
            background-color: rgba(0, 0, 0, 0.075);
            font-weight: bold;
         }
         .subtitle {
            font-size: 1.3rem;
            font-weight: bold;
            margin: 0;
            padding: 5px;
            margin-top: 5px;
            background-color: rgba(0, 0, 0, 0.075);
            text-align: center;
         }
         h3 {
            font-size: 2rem;
            font-weight: bold;
            margin: 0;
            padding: 5px;
            margin-top: 10px;
         }
         .paragraph {
            margin: 0.5rem 0 0.5rem;
         }
         .tab {
            margin: 0 1rem;
         }
         html {
            scroll-behavior: smooth;
         }
      </style>

      <title>13 & 14 Stripe P1 and Deploying to Production</title>
   </head>
   <body>
      <div class="container">
         <h1 class="display-3 text-center">
            13 & 14 Stripe P1 and Deploying to Production
            <hr />
         </h1>
         <header>
            <p class="paragraph">
               Overall description.
            </p>
         </header>

         <h2 id="00" class="subtitle">Index</h2>
         <table class="table table-striped">
            <thead>
               <tr>
                  <th scope="col">#</th>
                  <th scope="col">Topic</th>
                  <th scope="col">Description</th>
               </tr>
            </thead>
            <tbody>
               <tr>
                  <th scope="row">1</th>
                  <td>
                     <a href="#01">topicName</a>
                  </td>
                  <td>
                     <code>Code or description</code>
                  </td>
               </tr>
            </tbody>
         </table>

         <ul class="list-group">
            <li class="list-group-item">
               <a id="01" href="#00">Index</a>
               <h2 class="subtitle">Stripe Integration</h2>
               <p class="paragraph">
                  Stripe is the best software platform for running an internet business. They call themselves <em>the new standard in online payments</em>. And the DOCS are amazing. However... Since Colombia is a backwater, we don't have Stripe here... We will use a dummy test from Stripe for our app. And to do that we need a Stripe account. 
               </p>
               <p class="paragraph">
                  There are many things that can be done with Stripe that we will ignore in the course. We will go to the Developer tab and there we can see our API keys. There is a <strong>Publishable Key</strong> and a <strong>Secret key</strong> which are used in our apps to tell stripe that we want to use their services in our specific account. The Publishable Key is the one we will use for our test, the Secret Key is the one that we need to actually do charges through the use of a backend server. 
               </p>
               <p class="paragraph">
                  <strong>Appropriate Libraries</strong>
                  <br>
                  We <code>yarn add react-stripe-checkout</code> We create a new component/stripe-button where we import React and <code>import StripeCheckout from 'react-stripe-checkout'</code>. We create an FC that will get <code>({ price })</code> as a prop. We open {} for our FC because we need to do some conversion. Stripe handles values in cents, therefore we need to convert the price to cents. So we <code>const priceForStripe = price * 100;</code> and we also need our Publishable Key <code>const publishableKey = 'pk_test_JdfuRU40dN6HP7uJ7YMucKqj00nAmG8IWJ'</code>. We get a TS err, and if we ctrl+click we can see the props that this Component can take. There are a lot of props, but there are two mandatory ones <strong>token</strong> and <strong>stripeKey</strong>. token is a FN that takes a token as an argument, and a token has a bunch of things, one of them being a card, that has its own interface with a whole lot of things as well. (I love TS...). We can see the DOCS for more options and a description of what they do. 
               </p>
               <p class="paragraph">
                  <strong>StripeCheckout</strong>
                  <br>
                  We use a few props <code>label='Pay Now' name='CRWN Clothing Ltd.' billingAddress shippingAddress</code> Then we add a bunch of other things... Unitl we reach token. Token is the <em>on-success</em> callback that triggers when we submit. We create <code>const onToken = (token: Token) => { console.log(token); alert('Payment Successful')</code>. In a real app we would pass this token to the backend, which then creates the charge, however we don't need this so it is a dummy handler. We pass it as <code>token={onToken}</code> and finally we add <code>stripeKey={publishableKey}</code>. I moved these two to the top of the Component. We then <code>export default StripeCheckoutButton</code>
               </p>
               <p class="paragraph">
                  <strong>Checkout Component</strong>
                  <br>
                  We import our StripeCheckoutButton and add it at the bottom <code>StripeCheckoutButton price={total}</code> which now gives us access to the button in our app. Im getting better at TS typing. And if we click it, we get our component show automatically with styling, which is absolutely impressive, it even detects where I am... <strong>Note:</strong> I get an Update available message that says that I am using an older version of Stripe Checkout, and that the newer one is conversion-optimized and supports Apple Pay, Google Pay, and global payment methods. We use the dummy card provided by stripe and we can see that in our console we get the Object for our token that is what allows our backend to process the payment. We need to import a component for this because Stripe uses vanilla JS and these components allow us to not have to do the component from scratch and the integration from scratch by using someones third party code. We then add the warning message for the dummy card into our component. As a final touch we replace the favicon for react with our own favicon.ico. 
               </p>
               <a id="02" href="#00">Index</a>
               <h2 class="subtitle">Deploying to Heroku</h2>
               <p class="paragraph">
                  I have already done this many times before. We will run <code>heroku create projectName --buildpack https://github.com/mars/create-react-app-buildpack.git</code> A <strong>buildpack</strong> is a specific configuration for the build that we want so that it deploys our react as a <em>static website</em>. This is the best and most efficient way for us to host our react project made with CRA beacause our buildpack is a CRA buildpack. This buildpack will also use the <em>production build</em> of our React App (we don't have to run npm build ourselves). We use the name ecommerce-react-typescript. <strong>Note:</strong> my build failed because I had a .env file which stopped the build from being executed. This took about 3 minutes to execute. Now we have <a href="https://ecommerce-react-typescript.herokuapp.com/">Our Project</a> up on Heroku. We then added our URL to the <strong>Authorized Domains</strong> in our Firebase Console. 
               </p>
               <a id="03" href="#00">Index</a>
               <h2 class="subtitle">Optimizing Production Build</h2>
               <p class="paragraph">
                  How do we remove certain things for production while keeping them available during development, such as our logger? We do <code>if (process.env.NODE_ENV === 'development') middlewares.push(logger)</code> Inside of Node there is an <strong>evniornment</strong> variable. We can set environment variables, or Heroku can se environment variables. CRA has some defaults for this: development, production, test. When the <code>yarn build</code> script is executed, it tells whatever is hosting our app that it needs to switch our node environment variable to <em>production</em>. When we do <code>yarn start</code> and host in our local server, it is set to <em>development</em>. Now we can push to heroku and not use our logger middleware. Heroku makes deploying very easy. 
               </p>
               <a id="04" href="#00">Index</a>
               <h2 class="subtitle">CSS in JS</h2>
               <p class="paragraph">
                  One of the problems with CSS is that when it was concieved, we were only creating static websites that were single pages or collections of very few pages, and the styling was very basic. When our apps grow in scale (Facebook has 20,000 React Components), it is more likely that we may accidentally re-use the same class name for CSS styling. The problem is that all CSS shares one single <em>global namespace</em>. When we apply a style to a Component, JS takes that styling and puts it into the <strong>head</strong> of our application. The way we structure our app is a way for us to see how we are applying the styles to the component, however, the way that CSS applies them has not actually changed. In an example that uses the <em>card</em> className as a target, will apply it to any HTML element that has <em>card</em> in it. 
               </p>
               <p class="paragraph">
                  <strong>Solutions 1</strong>
                  <br>
                  There was a solution called the BEM convention, which is simply a way of naming your css targets based on the elements, however this creates a lot of mental overhead because it creates absurd css names. Fortunately we can now leverage JS to create our CSS files. React offers a way to do this through the use of the <strong>style</strong> prop in our element. We do this by writing a JS object with css targets and values in a cammelCase format, and passing it to styles <code>div style={ourStyleObj}</code> which adds the styles directly into our HTML element. The problem here is that we don't have access to all of the CSS selectors, such as hover, disabled, nth child, before, etc... 
               </p>
               <p class="paragraph">
                  <strong>CSS to JS</strong>
                  <br>
                  There are a few libraries that tackle this issue directly, the most popular one being <strong>styled-components</strong>, which is basically a JS library that renders our styles. There is a mentality that is prevalent that is called the <em>separation of concerns</em>, which web purists take to heart and just adapt to keeping CSS in CSS. The approach of using a CSS to JS library is merging this concerns but it is more inline with the React philosophy of components: <em>compartmentalize all of the code we need into our components.</em> With this approach we would be <em>scoping</em> or CSS to our component. This effectivelly eliminates the possibility of our CSS styling leaking into other components due to the <em>global namespace</em>. 
               </p>
               <a id="05" href="#00">Index</a>
               <h2 class="subtitle">Styled-components</h2>
               <p class="paragraph">
                  We do <code>yarn add styled-components</code>. This library creates new Components that are targetted by a style written in CSS kebab-case which we use to replace our HTML elements and creates a unique className for them so that we don't have namespace bleeding. Another benefit is that if we were to re-use a style for an element we could re-use the Component we created with that styling. We can also use Component props to target styles by passing functions to our style-components style object. 
               </p>
               <p class="paragraph">
                  <strong>HomePage conversion (easy)</strong>
                  <br>
                  We start by creating <code>homepage.styles.tsx</code> and <code>import styled from 'styled-components'</code>, which prompted us to add the @types/ for it. Then we do <code>const HomePageContainer = styled.div``</code> which opens us to write the styles. And then we copy the styles from ous scss file into our ``. And then we <code>export const HomePageContainer</code> Then in our Component we <code>import { HomePageContainer } from "./homepage.styles";</code> Then we erase all of our div and replace it with <code>HomePageContainer</code>. Now we are not using our scss file and we can see that our unique class name was generated. 
               </p>
               <p class="paragraph">
                  <strong>Header Component (More Complex)</strong>
                  <br>
                  We <code>import styled from 'styled-components';</code> and <code>import { Link } from 'react-router-dom';</code> and <code>export const HeaderContaner = styled.div` ... `</code> where we copy from our scss. We create <code>export cont LogoContainer = styled(Link)` ... `</code> because we are using a non native HTML element. This is the format, like a HOC. And then we can put the styles here. We add css to our <code>import styled, { css } from 'styled-components';</code> which allows us to write a block of CSS that we can pass in and render as CSS inside any of our styled components. This is beacuse we are applying the same style to a few components, and this allows us to re-use this code <code>export const OptionLink = styled(Link)`${OptionContainerStyles}`;</code> and do the same for <code>export const OptionDiv</code>. Now we remove all the classNames and replace our HTML elements with our styled-components and we have the same outcome. And adde benefit is that now we can CTRL+Click and see the styling applied to the element directly. 
               </p>
               <p class="paragraph">
                  <strong>Refactoring for less code and overhead</strong>
                  <br>
                  There is another way of having shared styles between components. We had an example before that two components shared styles, OptionLink and OptionDiv. We could change OptionDiv to <code>OptionLink as='div'</code> which would apply the same styling but render it and treat it as a div. We could also do this for our custom created components <code>as={ComponentName}</code>. Doing that we could remove the css import, code, and just pass it as Option Link. Now we have less overhead and code, and have perserved the same styles. 
               </p>
               <a id="06" href="#00">Index</a>
               <h2 class="subtitle">Styled-components in our App P2</h2>
               <p class="paragraph">
                  
               </p>
            </li>
         </ul>
      </div>

      <!-- Optional JavaScript -->
      <!-- jQuery first, then Popper.js, then Bootstrap JS -->
      <script
         src="https://code.jquery.com/jquery-3.4.1.slim.min.js"
         integrity="sha384-J6qa4849blE2+poT4WnyKhv5vZF5SrPo0iEjwBvKU7imGFAV0wwj1yYfoRSJoZ+n"
         crossorigin="anonymous"
      ></script>
      <script
         src="https://cdn.jsdelivr.net/npm/popper.js@1.16.0/dist/umd/popper.min.js"
         integrity="sha384-Q6E9RHvbIyZFJoft+2mJbHaEWldlvI9IOYy5n3zV9zzTtmI3UksdQRVvoxMfooAo"
         crossorigin="anonymous"
      ></script>
      <script
         src="https://stackpath.bootstrapcdn.com/bootstrap/4.4.1/js/bootstrap.min.js"
         integrity="sha384-wfSDF2E50Y2D1uUdj0O3uMBJnjuUD4Ih7YwaYd1iqfktj0Uod8GCExl3Og8ifwB6"
         crossorigin="anonymous"
      ></script>
   </body>
</html>
