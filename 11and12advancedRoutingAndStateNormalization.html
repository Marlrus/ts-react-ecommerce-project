<!doctype html>
<html lang="en">
  	<head>
		<!-- Required meta tags -->
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

		<!-- Bootstrap CSS -->
		<link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.4.1/css/bootstrap.min.css" integrity="sha384-Vkoo8x4CGsO3+Hhxv8T/Q5PaXtkKtu6ug5TOeNV6gBiFeWPGFN9MuhOf23Q9Ifjh" crossorigin="anonymous">
		<style>
			code{
				background-color: rgba(0,0,0,.075);
				font-weight: bold;
			}
			.subtitle{
				font-size: 1.3rem;
				font-weight: bold;
				margin: 0;
				padding: 5px;
				margin-top: 5px;
				background-color: rgba(0,0,0,.075);
				text-align: center;
			}
			h3{
				font-size: 2rem;
				font-weight: bold;
				margin: 0;
				padding: 5px;
				margin-top: 10px;
			}
			.paragraph{
				margin: 0.5rem 0 0.5rem;
			}
			.tab{
				margin: 0 1rem;
			}
			html{
				scroll-behavior: smooth;
			}
			</style>

		<title>11 and 12 Advanced Routing and State Normalization</title>
  	</head>
  	<body>
      
    <div class="container">
		<h1 class="display-3 text-center">11 and 12 Advanced Routing and State Normalization<hr></h1>
		<header>
			<p class="paragraph">
				Overall description.
			</p>
		</header>

		<h2 id="00" class="subtitle">Index</h2>
		<table class="table table-striped">
			<thead>
				<tr>
					<th scope="col">#</th>
					<th scope="col">Topic</th>
					<th scope="col">Description</th>
				</tr>
			</thead>
			<tbody>
				<tr>
					<th scope="row">1</th>
					<td>
						<a href="#01">topicName</a>
					</td>
					<td>
						<code>Code or description</code>
					</td>
				</tr>
			</tbody>
		</table>

		<ul class="list-group">
			<li class="list-group-item">
				<a id="01" href="#00">index</a>
				<h2 class="subtitle">Nested Routing In ShopPage</h2>
				<p class="paragraph">
               We will use the Route component in our ShopPage, until now we have only used it in App. We do <code>Route exact path={`${match.path}`} component={CollectionsOverview} </code> so that we can now have routes that go to our component. <code>match.path</code> is the current url stirng our component is in, so if we change it in the future, it will automatically adjust. We create a Page CategoryPage and move it to shop. Here we create a Route <code>Route path={${match.path/:categoryId}}</code> this makes it so that the param is flexible. We can do shop/anyId and we will get that string in our match that we can now use to find the category items we are using. We can access it through <code>match.params.categoryId</code> which will give us the string we have after our path so that we can use it in our CategoryPage component.
            </p>
            <p class="paragraph">
               Se will rename our CategoryPage component to Collection, to keep the standard we are keeping in our App. We change everything category to collection. 
            </p>
            <a id="02" href="#00">index</a>
				<h2 class="subtitle">Collection Routing and Selector</h2>
				<p class="paragraph">
               I had an err with my App, and I had to remove exact from the App route for ShopPage. This fixed it. We create a new <strong>shop selector</strong> where we create a <code>COLLECTION_ID_MAP</code> that pams strings to numbers to use in our code. I used the TS type, enum <code>enum COLLECTION_ID_MAP { hats = 1, sneakers, ... }</code> that does just that. Then I created the selector <code>export const selectCollection = ( collectionUrlParam: keyof typeof COLLECTION_ID_MAP ) => ...</code> This makes it so that the param is always going to be a key of our COLLECTION_ID_MAP, which makes TS stop erring. Then our selector <code>createSelector(selectCollections, (collections) => ....</code> where we use <code>collections.find(colleciton => collection.id === COLLECTION_ID_MAP[collectionUrlParam])</code> which finds our collection based on what we get in the URL. 
            </p>
            <p class="paragraph">
               Ill attempt to do the next part myself. This was much harder and I actually had to do the video on some parts. I created a new type in <strong>shop.types</strong> <code>export type collectionIdMapKeys = keyof typeof COLLECTION_ID_MAP;</code> Which I swapped in the selectors. Then trouble began in the CollectionPage. I did the standard map stateToProps() however, for my selector I couldn't use state. This is where I saw the video: <em>The second argument for mapStateToProps are the ownProps of the element being passed through connector.</em> This is a mouthfull, but the hard part is typing it. We run <code>const mapStateToProps = (state: State, ownProps: any ) => ({ ... })</code> and inside <code>collection: selectCollection(ownProps.match.params.collectionId)</code> however, we have no TS support. The problem being that what we can get after params depends completely on the component, and TS cannot infer it. 
            </p>
            <p class="paragraph">
               <strong>params solution</strong>
               <br>
               I found a <a href="https://stackoverflow.com/questions/48138111/what-typescript-type-should-i-use-to-reference-the-match-object-in-my-props">handy answer</a> that showed that RouteComponentProps can take a <strong>generic</strong> to type what is in match params which sets our generic as the custom params we can use. I <code>interface Params { collectionId: collectionIdMapKeys }</code> that is basically what I expect as a param, and I can now pass it to mapStateToProps() <code>ownProps: RouteComponentProps&lt;CollectionPageParams></code> which gives TS support and stops the err. However, our selectCollection is a curried Fn which means that to work, we need to pass the state so we have to do <code>()(state)</code> which will now run the selector appropriately. This happens because our selector uses another selector that needs the state. Then we can pass this to the component through our ConnectedProps by adding <code>& RouteComponentProps&lt;CollectionPageParams></code> Which gives us strong typing in our Component. I will not have this problem again in the future.
            </p>
            <a id="03" href="#00">index</a>
				<h2 class="subtitle">Data Normalization + Collection Page</h2>
				<p class="paragraph">
               We begin by doing some changes to the scss of collection-item. We change width from 22% to 22vw. 22% is 22% of the containing div, 22 view width is 22% of the actual window, and it responds to the window's change in size. We then go to CollectionPage and <code>const { title, items } = collection!;</code> to use in our component. We need ! because, TS knows that a search might return undefined. We then create a div className collection-page, and inside an h2 className title with <code>{title}</code> and then a div className items that does <code>items.map(item => ( ... ))</code> where we render <code>CollectionItem key={item.id} item={item}</code> and TS is happy. We copy and paste the styles. And now we have all of our elements and we re-used CollectionItem that we also used in ShopPage.
            </p>
            <p class="paragraph">
               <strong>Directory and efficient storage</strong>
               <br>
               We go to the directory reducer and change the Initial state to have the correct links <code>shop/hats</code> etc for each category, and now our homepage takes us to the categories we want. Right now we have our collections in an array, meaning that we find it using the find() method. The issue is that if we had a very large array, using .find() has to iterate over all the array to find the collection and if we are looking for the last item it might be a slow process. Therefore we should consider storing the data in an object. This way of storing data is called <strong>data Normalization</strong>. 
            </p>
            <p class="paragraph">
               <strong>Normalizing shop data</strong>
               <br>
               We remove the [] and replace them with {} then we add the category title to every collection item <code>hats: { ... }</code> etc. And now our data is normalized. Since we did this, we have to update our selector. We remove .find() and do <code>createSelector( selectCollections, (collections) => collections[collectionUrlParam] )</code> that will match the key in our object. Now we dont need the <code>enum</code> so I change the type to <code>type collectionIdKeys = string literals</code>. We have no successfuly data normalized but I got a TS error in CollectionsOverview because it uses map() on our elements but they are not an array anymore. I commented it out for the moment. We can do this for every array, and get this benefit, but it would be a lot of refactoring, and for small arrays it is not that crucial. This is called Object Hash Table data structure and we can learn more about it in <a href="https://www.kirupa.com/html5/hashtables_vs_arrays.htm">hashtables vs arrays</a>. I also changed my code in shop.types to <code>export type collectionIdKeys = keyof typeof SHOP_DATA</code> to get a consistent string literal.
            </p>
            <a id="04" href="#00">index</a>
				<h2 class="subtitle">Data Flow In Our App</h2>
				<p class="paragraph">
               We will fix our CollectionsOverview by creating a new selector for our collections that will convert our object into an array. We do this by creating <code>export const selectCollectionsAsArray = createSelector(selectCollections, collections => ... )</code> Where we do <code>(Object.keys(collections) as Array&lt;keyof typeof collections>).map(key => collections[key])</code> which took a while to type correctly. This is the safest way to do this, even more than using collectionIdKeys. We import it into CollectionsOverview and change it in mapStateToProps and we get everything working. I found this pretty handy and created a util Fn for doing this to any object <code>const convertToArray = &lt;T extends object>(object: T) => (Object.keys(object) as Array&lt;keyof typeof object>).map(key=> object[key])</code> which I can now use for any data I normalize and then want as an array. I use it in the selector with <code>selectCollections, (collections) => convertToArray(collections)</code>
            </p>
            <p class="paragraph">
               <strong>CollectionPreview</strong>
               <br>
               Right now we are passing the whole array to CollectionPreview, and inside of it we are filtering to just have 4 items. We could do this in our selector if we wanted to, however this is more of an issue of principle than it is of good practice. Yihua prefers to keep it this way, because if we want to display more items in the future in a scroll or button like feature, we would not need to change the selector, but instead change the code in CollectionPreview which is the one actually in charge of what gets displayed. I decided to make the titles in CollectionPreview become links to the categories. I <code>import { withRouter, RouteComponentProps } from 'react-router-dom';</code> then <code>export default withRouter(CollectionPreview);</code> and changed <code>interface CollectionPreviewPorps extends RouteComponentProps { ... }</code> which gives us access and TS support for our router props. Then I did <code>onClick={()=> history.push(`${match.path}/${title.toLowerCase()}`) }</code> which redirects to the page we want and is dynamic. I also added <code>cursor: pointer;</code> to the title. And the feature was added.
            </p>
			</li>
		</ul>
	</div>

	<!-- Optional JavaScript -->
	<!-- jQuery first, then Popper.js, then Bootstrap JS -->
	<script src="https://code.jquery.com/jquery-3.4.1.slim.min.js" integrity="sha384-J6qa4849blE2+poT4WnyKhv5vZF5SrPo0iEjwBvKU7imGFAV0wwj1yYfoRSJoZ+n" crossorigin="anonymous"></script>
	<script src="https://cdn.jsdelivr.net/npm/popper.js@1.16.0/dist/umd/popper.min.js" integrity="sha384-Q6E9RHvbIyZFJoft+2mJbHaEWldlvI9IOYy5n3zV9zzTtmI3UksdQRVvoxMfooAo" crossorigin="anonymous"></script>
	<script src="https://stackpath.bootstrapcdn.com/bootstrap/4.4.1/js/bootstrap.min.js" integrity="sha384-wfSDF2E50Y2D1uUdj0O3uMBJnjuUD4Ih7YwaYd1iqfktj0Uod8GCExl3Og8ifwB6" crossorigin="anonymous"></script>
	</body>
</html>