<!doctype html>
<html lang="en">
  	<head>
		<!-- Required meta tags -->
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

		<!-- Bootstrap CSS -->
		<link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.4.1/css/bootstrap.min.css" integrity="sha384-Vkoo8x4CGsO3+Hhxv8T/Q5PaXtkKtu6ug5TOeNV6gBiFeWPGFN9MuhOf23Q9Ifjh" crossorigin="anonymous">
		<style>
			code{
				background-color: rgba(0,0,0,.075);
				font-weight: bold;
			}
			.subtitle{
				font-size: 1.3rem;
				font-weight: bold;
				margin: 0;
				padding: 5px;
				margin-top: 5px;
				background-color: rgba(0,0,0,.075);
				text-align: center;
			}
			h3{
				font-size: 2rem;
				font-weight: bold;
				margin: 0;
				padding: 5px;
				margin-top: 10px;
			}
			.paragraph{
				margin: 0.5rem 0 0.5rem;
			}
			.tab{
				margin: 0 1rem;
			}
			html{
				scroll-behavior: smooth;
			}
			</style>

		<title>18 Asynchronous Redux</title>
  	</head>
  	<body>
      
    <div class="container">
		<h1 class="display-3 text-center">18 Asynchronous Redux<hr></h1>
		<header>
			<p class="paragraph">
				Overall description.
			</p>
		</header>

		<h2 id="00" class="subtitle">Index</h2>
		<table class="table table-striped">
			<thead>
				<tr>
					<th scope="col">#</th>
					<th scope="col">Topic</th>
					<th scope="col">Description</th>
				</tr>
			</thead>
			<tbody>
				<tr>
					<th scope="row">1</th>
					<td>
						<a href="#01">topicName</a>
					</td>
					<td>
						<code>Code or description</code>
					</td>
				</tr>
			</tbody>
		</table>

		<ul class="list-group">
			<li class="list-group-item">
				<a id="01" href="#00">Index</a>
				<h2 class="subtitle">Observables + Observable Pattern</h2>
				<p class="paragraph">
					We will finally talk about <strong>Subscriptions</strong>. It is a pattern called the <strong>observer pattern</strong>. Imagine a linear stream of events, where each node is an event. An observable is some piece of code that wraps around a stream of events so that we can do something with the value on that piece of data at each event. The <strong>Observer</strong> is a piece of code that has 3 Fn calls: next() which is just the code that we execute when a new event happens (Do something with value). An error() is code that we execute when an error occurs. The third is complete(), which is an optional call, that does something once the event or stream finishes. 
				</p>
				<p class="paragraph">
					A stream can definitely stop emmiting data. An example would be getting data from our backend in an undefined amount of time. Once we get the data, we know that we don't need any more data. So we can stop listening and shut down that stream. The observable stops that stream at that point and the complete() called for every observer will get called. This happens through what is called a <strong>subscription</strong>. The subscription is a way of tying our observer using what is called a <strong>listener</strong> to the observable. The observer is listening to these values and we are subscribing to the observer's stream of events. 
				</p>
				<p class="paragraph">
					<strong>Firebase Auth</strong>
					<br>
					We are already doing this in our auth.onAuthStateChanged() method. The Fn that we call, is the next() call we get. Here onAuthStateChanged() is the stream of events, or observable. There is an indefinite stream of data on the firebase auth library that doesn't end because users can keep logging in and out indefinitely. Every time that happens fire base sends to us another piece in that stream. The function we pass to this stream is a very basic observer. As a second argument, we could pass an error call, which we haven't done. The complete() call very rarely happens inside of firebase because it is a live DB, meaning that updates can always happen. This is why we cannot pass a complete() callback to our Fn. 
				</p>
				<p class="paragraph">
					<strong>unsubscribeFromAuth</strong>
					<br>
					Technically speaking, our subscription or listener, never ends because the stream is always open. With the observer/listener we have set a listener permanently that is always listening to events. If the component unmounts, we don't care about this listener as far as this component is concerned anymore. But because the stream always exists in the auth library it will always hold on to the listener. To stop this we have to <strong>unsubscribe</strong> from it. We need to tell it to stop listening when the component unmounts. Firebase gives us back an unsubscribe Fn. We have <code>this.unsubscribeFromAuth = auth.onAuthStateChanged( ... )</code> That when we call <code>this.unsubscrubeFromAuth()</code> it will eliminate that listener. When we instanciate our Fn, it returns a Fn that points to the listener we just created, that when it gets called it unsubscribes or gets rid of the listener. This ends the subscription from our observer, and the observable stream continues in peace. 
				</p>
				<p class="paragraph">
					An observable can have any number of observers that can have any type of next(), error(), and complete() calls. 
				</p>
				<a id="02" href="#00">Index</a>
				<h2 class="subtitle">Promise Pattern</h2>
				<p class="paragraph">
					If we use a different library, we might not be use the Observer pattern. This would happen if we use another DB or service. Here we use our Promise pattern works. In Firestore we can use both patterns. In our ShopPage component we use onSnapshot() which uses the observer pattern. To use the promise pattern we would call .get() which fetches the JSON data. We would <code>collectionRef.get().then(snapshot => { ... } )</code>. The caveat here is the we will only get new data when we re-mount our shop because we are not subscribed to the stream of events. 
				</p>
				<p class="paragraph">
					<strong>Fetch API pattern</strong>
					<br>
					We can also use Firestore as an API that we would call using the native JS fetch(). Firebase allows us to feth using a URL <code>fetch('firebaseAPIUrl').then(response=> response.json()).then(collections => doSomething)</code>. Fetching data like this in Firestore is hell... You get a very deeply nested and weirdly structured object that holds the data very deeply in the response object (about 8 levels deep). We will preserve the .get() method to segway into async Redux.
				</p>
				<p class="paragraph">
					<strong>Async Redux</strong>
					<br>
					We will use a Redux that will handle the async nature of our .get() call and then fire the event in our ShopComponent. Why would we want to move the logic out of componentDidMount()? The only reason we would do this is if we would be fetching some data from our backend, converting it and storing it in our reducer somwehere else in our app. In our case, if we never go to our shop page, we would have not fired our UPDATE_COLLECTIONS action. This means that in our home page we won't have the collections in our state. We don't want to move this into our App component either because it would be a lot of loading and the user might not even visit the shop page or other pages that need the data. If we extend our app in a way that we might need the data somewhere that doesnt load our ShopPage Component, we would need to repeat the code, which we don't want to do. We would handle it by moving it into an async Redux Action. 
				</p>
				<a id="03" href="#00">Index</a>
				<h2 class="subtitle">Redux Thunk</h2>
				<p class="paragraph">
					We <code>yarn add redux-thunk @types/redux-thunk</code>. Redux thunk is a piece of middleware that allows us to fire Fns. We need to add it in our store.ts file. We import it and then <code>const middleware = [thunk as ThunkMiddleware];</code> which needs to be typed like that to avoid TS errs. We then go to shop.types.ts and create 3 new action types: FETCH_COLLECTIONS_START, FETCH_COLLECTIONS_SUCCESS, FETCH_COLLECTIONS_FAILURE, which handle all the states an API call can be in. 
				</p>
				<p class="paragraph">
					<strong>Shop Reducer</strong>
					<br>
					In our shop.reducer.ts we add <code>isFetching: false, errorMessage: undefined</code> to our initial state. We move the calling state from the component that we had with loading: false, into Redux. We remove the UPDATE_COLLECTIONS case and replace it with our new action types. On START we <code>return { ...state, isLoading: true }</code>, on SUCCESS <code>return { ...state, isLoading: false, collections: action.payload }</code> and on FAILURE we will <code>return { ...state, isLoading: false, errorMessage: action.payload }</code>. 
				</p>
				<p class="paragraph">
					<strong>Shop Actions</strong>
					<br>
					We will leverage Thunk in our actions. We create 3 actions fetchCollectionsStart takes no args and only returns its type. We only need this one to set <code>isFetching: true</code> in our reducer. Then we <code>export const fetchCollectionsStart = (): ShopActions => ({ ... })</code> That returns its type and <code>payload: collectionsMap</code> which will be the same as updateCollections. Then we do <code>fetchChollectionsFailure = (errorMessage: string) => ({ ... })</code> That will have <code>payload: errorMessage</code> to handle the error that can emerge from the async action. We type all of this in our shop.types.ts which is pretty complex. 
				</p>
				<p class="paragraph">
					<strong>The thunk action</strong>
					<br>
					We take the logic from our ShopComponent and paste it in our new thunk action. A thunk action is like a normal action but it returns a Fn instead of an action object: <code>export const fetchCollectionsStartAsync = () => { return ( dispatch: ThunkDispatch &lt;ShopState, undefined, ShopActions> ) => { ... }</code> This is similar to what we do in mapDispatchToProps(). The typing here takes the State we expect, the second one I don't understand, and the third one are the possible actions. Inside we have the logic we had in our component, inside we call the actions we just created: <code>dispatch(fetchCollectionsStart())</code> after we get our collectionRef. Then we do our .get() fetching and in the .then() we <code>dispatch(fetchCollectionSuccess(collectionsMap)</code> after we get our collections map. Then in the .catch() we <code>dispatch(fetchChollectionsFailure(error.message))</code> which is our third action. Since we enabled redux-thunk middleware, anytime you dispatch() a Fn instead of an object, the middleware will call that Fn with dispatch() method itself as the first argument. In the store.ts file, I had to alter the typing for thunk-middleware <code>[thunk as ThunkMiddleware&lt;State, Actions>]</code> which tells it what the State will be, and what Actions to handle. I created an <code>type Actions = ShopActions</code> which I can later add actions from other reducers so that it expects them.
				</p>
				<p class="paragraph">
					<strong>Shop Component</strong>
					<br>
					We remove the firestore import statement. We remove useState and useEffect. Then we change our actions import to bring <code>fetchCollectionsStartAsync</code>. We create a new selector <code>export const selectIsCollectionFetching = createSelector( [selectShop], shop => shop.isFetching )</code> We then import it into our Component. We clear our mapDispatchToProps(). We need to alter all our code to use the new actions and new state. We start with <code>const mapStateToProps = (state: State) => ({ isCollectionFetching: selectIsCollectionFetching(state) })</code> which will give us access to the boolean we set in the state to determine if we are fetching data from a backend. Then on mapDispatchToProps() we need to change the typing because we are using a Thunk <code>dispatch: ThunkDispatch&lt;ShopState, undefined, ShopActions></code> which will type our dispatch Fn correctly and then <code>fetchCollectionsStartAsync: () => dispatch(fetchCollectionsStartAsync())</code>. <strong>Note:</strong> I made the error of not destructuring this from the props in our FC for the SECOND TIME!. DESTRUCTURE IT TS will not err because the Fn has the same name, or do a diff name.... Now we destructure <code>isCollectionFetching, fetchCollectionsStartAsync</code> from our component to use. We set the <code>isLoading={isCollectionFetching}</code> so that the spinner shows up depending on the state given by our selector. Then we need to do componentDidMount(), however,since we are using useEffect() we need to <code>useEffect(()=> { fetchCollectionsStartAsync() }, [fetchCollectionsStartAsync] )</code> which makes useEffect() behave like componentDidMount. Now we have everything working using Redux Thunk. This is a common Redux pattern that is very useful. 
				</p>
			</li>
		</ul>
	</div>

	<!-- Optional JavaScript -->
	<!-- jQuery first, then Popper.js, then Bootstrap JS -->
	<script src="https://code.jquery.com/jquery-3.4.1.slim.min.js" integrity="sha384-J6qa4849blE2+poT4WnyKhv5vZF5SrPo0iEjwBvKU7imGFAV0wwj1yYfoRSJoZ+n" crossorigin="anonymous"></script>
	<script src="https://cdn.jsdelivr.net/npm/popper.js@1.16.0/dist/umd/popper.min.js" integrity="sha384-Q6E9RHvbIyZFJoft+2mJbHaEWldlvI9IOYy5n3zV9zzTtmI3UksdQRVvoxMfooAo" crossorigin="anonymous"></script>
	<script src="https://stackpath.bootstrapcdn.com/bootstrap/4.4.1/js/bootstrap.min.js" integrity="sha384-wfSDF2E50Y2D1uUdj0O3uMBJnjuUD4Ih7YwaYd1iqfktj0Uod8GCExl3Og8ifwB6" crossorigin="anonymous"></script>
	</body>
</html>